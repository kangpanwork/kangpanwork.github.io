[{"title":"MyBatis-Plugin-Development","url":"/2022/03/10/MyBatis-Plugin-Development/","content":"\n\n\n## MyBatis插件开发流程\n\n- 类实现Interceptor接口；\n\n- 类上添加注解\n\n  ```\n  @Intercepts({@Signature(type, method, args)})\n  ```\n\n  - **type**：需要拦截的对象，只可取四大对象之一Executor.class、StatementHandler.class、ParameterHandler.class、ResultSetHandler.class。\n  - **method**：拦截的对象方法。\n  - **args**：拦截的对象方法参数。\n\n- 实现拦截的方法Object intercept(Invocation invocation)。\n\n##  Interceptor接口\n\n```\npublic interface Interceptor {\n\n    /**\n     * 此方法将直接覆盖被拦截对象的原有方法\n     *\n     * @param invocation 通过该对象可以反射调度拦截对象的方法\n     * @return\n     * @throws Throwable\n     */\n    Object intercept(Invocation invocation) throws Throwable;\n\n    /**\n     * 为被拦截对象生成一个代理对象，并返回它\n     *\n     * @param target 被拦截的对象\n     * @return\n     */\n    Object plugin(Object target);\n\n    /**\n     * 设置插件配置的参数\n     *\n     * @param properties 插件配置的参数\n     */\n    void setProperties(Properties properties);\n\n}\n```\n\n## 步骤\n\n### 确定拦截的方法签名\n\n需要在实现Interceptor接口的类上加入@Intercepts({@Signature(type, method, args)})注解才能够运行插件。\n\n#### type－拦截的对象\n\n- Executor 执行的SQL 全过程，包括组装参数、组装结果返回和执行`SQL`的过程等都可以拦截。\n- StatementHandler 执行SQL的过程，拦截该对象可以重写执行SQL的过程。\n- ParameterHandler 执行SQL 的参数组装，拦截该对象可以重写组装参数的规则。\n- ResultSetHandler 执行结果的组装，拦截该对象可以重写组装结果的规则。\n\n对于分页插件，我们只需要拦截StatementHandler对象，重写SELECT类型的SQL语句，实现分页功能。\n\n\n\n#### method－拦截的方法\n\n我们已经能够确定拦截的对象是StatementHandler了，现在我们要确定拦截的是哪个方法，因为StatementHandler是通过prepare方法对SQL进行预编译的，所以我们需要对prepare方法进行拦截，在这个方法执行之前，完成SQL的重新编写，加入limit。\n\n**StatementHandler**\n\n```\npublic interface StatementHandler {\n\n  /**\n   * 预编译SQL\n   *\n   * @param connection\n   * @return\n   * @throws SQLException\n   */\n  Statement prepare(Connection connection)\n      throws SQLException;\n\n  /**\n   * 设置参数\n   *\n   * @param statement\n   * @throws SQLException\n   */\n  void parameterize(Statement statement)\n      throws SQLException;\n\n  /**\n   * 批处理\n   *\n   * @param statement\n   * @throws SQLException\n   */\n  void batch(Statement statement)\n      throws SQLException;\n\n  /**\n   * 执行更新操作\n   *\n   * @param statement\n   * @return 返回影响行数\n   * @throws SQLException\n   */\n  int update(Statement statement)\n      throws SQLException;\n\n  /**\n   * 执行查询操作，将结果交给ResultHandler进行结果的组装\n   *\n   * @param statement\n   * @param resultHandler\n   * @param <E>\n   * @return 返回查询的数据列表\n   * @throws SQLException\n   */\n  <E> List<E> query(Statement statement, ResultHandler resultHandler)\n      throws SQLException;\n\n  /**\n   * 得到绑定的sql\n   * \n   * @return\n   */\n  BoundSql getBoundSql();\n\n  /**\n   * 得到参数处理器\n   * \n   * @return\n   */\n  ParameterHandler getParameterHandler();\n\n}\n```\n\n#### args－拦截的参数\n\nargs是一个Class类型的数组，表示的是被拦截方法的参数列表。由于我们已经确定了拦截的是StatementHandler的prepare方法，而该方法只有一个参数Connection，所以我们只需要拦截这一个参数即可。\n\n### 实现拦截方法\n\n定义一个封装分页参数的类Page\n\n```\npublic class Page {\n\n    /**\n     * 当前页码\n     */\n    private Integer pageIndex;\n    /**\n     * 每页数据条数\n     */\n    private Integer pageSize;\n    /**\n     * 总数据数\n     */\n    private Integer total;\n    /**\n     * 总页数\n     */\n    private Integer totalPage;\n\n    public Page() {\n    }\n\n    public Page(Integer pageIndex, Integer pageSize) {\n        this.pageIndex = pageIndex;\n        this.pageSize = pageSize;\n    }\n\t// 省略get、set方法...\n}\n```\n\n实现插件分页的功能\n\n```\nimport org.apache.ibatis.executor.parameter.ParameterHandler;\nimport org.apache.ibatis.executor.statement.StatementHandler;\nimport org.apache.ibatis.mapping.BoundSql;\nimport org.apache.ibatis.mapping.MappedStatement;\nimport org.apache.ibatis.plugin.*;\nimport org.apache.ibatis.reflection.MetaObject;\nimport org.apache.ibatis.reflection.SystemMetaObject;\nimport org.apache.ibatis.scripting.defaults.DefaultParameterHandler;\nimport org.apache.ibatis.session.Configuration;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\n@Intercepts({@Signature(\n        type = StatementHandler.class,\n        method = \"prepare\",\n        args = {Connection.class}\n)})\npublic class PagingPlugin implements Interceptor {\n\n    /**\n     * 默认页码\n     */\n    private Integer defaultPageIndex;\n    /**\n     * 默认每页数据条数\n     */\n    private Integer defaultPageSize;\n\n    public Object intercept(Invocation invocation) throws Throwable {\n        StatementHandler statementHandler = getUnProxyObject(invocation);\n        MetaObject metaObject = SystemMetaObject.forObject(statementHandler);\n        String sql = getSql(metaObject);\n        if (!checkSelect(sql)) {\n            // 不是select语句，进入责任链下一层\n            return invocation.proceed();\n        }\n\n        BoundSql boundSql = (BoundSql) metaObject.getValue(\"delegate.boundSql\");\n        Object parameterObject = boundSql.getParameterObject();\n        Page page = getPage(parameterObject);\n        if (page == null) {\n            // 没有传入page对象，不执行分页处理，进入责任链下一层\n            return invocation.proceed();\n        }\n\n        // 设置分页默认值\n        if (page.getPageIndex() == null) {\n            page.setPageIndex(this.defaultPageIndex);\n        }\n        if (page.getPageSize() == null) {\n            page.setPageSize(this.defaultPageSize);\n        }\n        // 设置分页总数，数据总数\n        setTotalToPage(page, invocation, metaObject, boundSql);\n        // 校验分页参数\n        checkPage(page);\n        return changeSql(invocation, metaObject, boundSql, page);\n    }\n\n    public Object plugin(Object target) {\n        // 生成代理对象\n        return Plugin.wrap(target, this);\n    }\n\n    public void setProperties(Properties properties) {\n        // 初始化配置的默认页码，无配置则默认1\n        this.defaultPageIndex = Integer.parseInt(properties.getProperty(\"default.pageIndex\", \"1\"));\n        // 初始化配置的默认数据条数，无配置则默认20\n        this.defaultPageSize = Integer.parseInt(properties.getProperty(\"default.pageSize\", \"20\"));\n    }\n\n    /**\n     * 从代理对象中分离出真实对象\n     *\n     * @param invocation\n     * @return\n     */\n    private StatementHandler getUnProxyObject(Invocation invocation) {\n        // 取出被拦截的对象\n        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();\n        MetaObject metaStmtHandler = SystemMetaObject.forObject(statementHandler);\n        Object object = null;\n        // 分离代理对象\n        while (metaStmtHandler.hasGetter(\"h\")) {\n            object = metaStmtHandler.getValue(\"h\");\n            metaStmtHandler = SystemMetaObject.forObject(object);\n        }\n\n        return object == null ? statementHandler : (StatementHandler) object;\n    }\n\n    /**\n     * 判断是否是select语句\n     *\n     * @param sql\n     * @return\n     */\n    private boolean checkSelect(String sql) {\n        // 去除sql的前后空格，并将sql转换成小写\n        sql = sql.trim().toLowerCase();\n        return sql.indexOf(\"select\") == 0;\n    }\n\n    /**\n     * 获取分页参数\n     *\n     * @param parameterObject\n     * @return\n     */\n    private Page getPage(Object parameterObject) {\n        if (parameterObject == null) {\n            return null;\n        }\n\n        if (parameterObject instanceof Map) {\n            // 如果传入的参数是map类型的，则遍历map取出Page对象\n            Map<String, Object> parameMap = (Map<String, Object>) parameterObject;\n            Set<String> keySet = parameMap.keySet();\n            for (String key : keySet) {\n                Object value = parameMap.get(key);\n                if (value instanceof Page) {\n                    // 返回Page对象\n                    return (Page) value;\n                }\n            }\n        } else if (parameterObject instanceof Page) {\n            // 如果传入的是Page类型，则直接返回该对象\n            return (Page) parameterObject;\n        }\n\n        // 初步判断并没有传入Page类型的参数，返回null\n        return null;\n    }\n\n    /**\n     * 获取数据总数\n     *\n     * @param invocation\n     * @param metaObject\n     * @param boundSql\n     * @return\n     */\n    private int getTotal(Invocation invocation, MetaObject metaObject, BoundSql boundSql) {\n        // 获取当前的mappedStatement对象\n        MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(\"delegate.mappedStatement\");\n        // 获取配置对象\n        Configuration configuration = mappedStatement.getConfiguration();\n        // 获取当前需要执行的sql\n        String sql = getSql(metaObject);\n        // 改写sql语句，实现返回数据总数 $_paging取名是为了防止数据库表重名\n        String countSql = \"select count(*) as total from (\" + sql + \") $_paging\";\n        // 获取拦截方法参数，拦截的是connection对象\n        Connection connection = (Connection) invocation.getArgs()[0];\n        PreparedStatement pstmt = null;\n        int total = 0;\n\n        try {\n            // 预编译查询数据总数的sql语句\n            pstmt = connection.prepareStatement(countSql);\n            // 构建boundSql对象\n            BoundSql countBoundSql = new BoundSql(configuration, countSql, boundSql.getParameterMappings(),\n                    boundSql.getParameterObject());\n            // 构建parameterHandler用于设置sql参数\n            ParameterHandler parameterHandler = new DefaultParameterHandler(mappedStatement, boundSql.getParameterObject(),\n                    countBoundSql);\n            // 设置sql参数\n            parameterHandler.setParameters(pstmt);\n            //执行查询\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                total = rs.getInt(\"total\");\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (pstmt != null) {\n                try {\n                    pstmt.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        // 返回总数据数\n        return total;\n    }\n\n    /**\n     * 设置总数据数、总页数\n     *\n     * @param page\n     * @param invocation\n     * @param metaObject\n     * @param boundSql\n     */\n    private void setTotalToPage(Page page, Invocation invocation, MetaObject metaObject, BoundSql boundSql) {\n        // 总数据数\n        int total = getTotal(invocation, metaObject, boundSql);\n        // 计算总页数\n        int totalPage = total / page.getPageSize();\n        if (total % page.getPageSize() != 0) {\n            totalPage = totalPage + 1;\n        }\n\n        page.setTotal(total);\n        page.setTotalPage(totalPage);\n    }\n\n    /**\n     * 校验分页参数\n     *\n     * @param page\n     */\n    private void checkPage(Page page) {\n        // 如果当前页码大于总页数，抛出异常\n        if (page.getPageIndex() > page.getTotalPage()) {\n            throw new RuntimeException(\"当前页码［\" + page.getPageIndex() + \"］大于总页数［\" + page.getTotalPage() + \"］\");\n        }\n        // 如果当前页码小于总页数，抛出异常\n        if (page.getPageIndex() < 1) {\n            throw new RuntimeException(\"当前页码［\" + page.getPageIndex() + \"］小于［1］\");\n        }\n    }\n\n    /**\n     * 修改当前查询的sql\n     *\n     * @param invocation\n     * @param metaObject\n     * @param boundSql\n     * @param page\n     * @return\n     */\n    private Object changeSql(Invocation invocation, MetaObject metaObject, BoundSql boundSql, Page page) throws Exception {\n        // 获取当前查询的sql\n        String sql = getSql(metaObject);\n        // 修改sql，$_paging_table_limit取名是为了防止数据库表重名\n        String newSql = \"select * from (\" + sql + \") $_paging_table_limit limit ?, ?\";\n        // 设置当前sql为修改后的sql\n        setSql(metaObject, newSql);\n\n        // 获取PreparedStatement对象\n        PreparedStatement pstmt = (PreparedStatement) invocation.proceed();\n        // 获取sql的总参数个数\n        int parameCount = pstmt.getParameterMetaData().getParameterCount();\n        // 设置分页参数\n        pstmt.setInt(parameCount - 1, (page.getPageIndex() - 1) * page.getPageSize());\n        pstmt.setInt(parameCount, page.getPageSize());\n\n        return pstmt;\n    }\n\n    /**\n     * 获取当前查询的sql\n     *\n     * @param metaObject\n     * @return\n     */\n    private String getSql(MetaObject metaObject) {\n        return (String) metaObject.getValue(\"delegate.boundSql.sql\");\n    }\n\n    /**\n     * 设置当前查询的sql\n     *\n     * @param metaObject\n     */\n    private void setSql(MetaObject metaObject, String sql) {\n        metaObject.setValue(\"delegate.boundSql.sql\", sql);\n    }\n}\n```\n\n### 配置分页插件\n\n在mybatis-config.xml配置文件中配置自定义的分页插件\n\n```\n<plugins>\n\t<plugin interceptor=\"PagingPlugin\">\n\t\t<property name=\"default.pageIndex\" value=\"1\"/>\n\t\t<property name=\"default.pageSize\" value=\"20\"/>\n\t</plugin>\n</plugins>\n```\n\n### 实现DAO\n\n```\npublic class Role {\n\n   private Long id;\n   private String roleName;\n   private String note;\n   // 省略get、set...\n}\n```\n\n定义Mapper接口，通过分页对象查询角色列表\n\n```\npublic interface RoleMapper {\n    List<Role> listRoleByPage(Page page);\n}\n```\n\n定义Mapper.xml编写查询的SQL语句\n\n```\n<mapper namespace=\"RoleMapper\">\n    <select id=\"listRoleByPage\" resultType=\"Role\">\n        SELECT id, role_name, note FROM role\n    </select>\n</mapper>\n```\n\n### 测试分页插件\n\n测试代码\n\n```\n@Test\npublic void test() {\n\tInputStream inputStream = null;\n\tSqlSessionFactory sqlSessionFactory;\n\tSqlSession sqlSession = null;\n\ttry {\n\t\tinputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\t\tsqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n\t\tsqlSession = sqlSessionFactory.openSession();\n\t\tRoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n\t\t// 分页参数，从第一页开始，每页显示5条数据\n\t\tPage page = new Page(1, 5);\n\t\tList<Role> roleList = roleMapper.listRoleByPage(page);\n\t\tSystem.out.println(\"===分页信息===\");\n\t\tSystem.out.println(\"当前页码：\" + page.getPageIndex());\n\t\tSystem.out.println(\"每页显示数据数：\" + page.getPageSize());\n\t\tSystem.out.println(\"总数据数：\" + page.getTotal());\n\t\tSystem.out.println(\"总页数：\" + page.getTotalPage());\n\t\tSystem.out.println(\"=============\");\n\t\tSystem.out.println(\"===数据列表===\");\n\t\tfor (Role role : roleList) {\n\t\t\tSystem.out.println(role);\n\t\t}\n\t} catch (IOException e) {\n\t\te.printStackTrace();\n\t} finally {\n\t\tif (sqlSession != null) {\n\t\t\tsqlSession.close();\n\t\t}\n\t\tif (inputStream != null) {\n\t\t\ttry {\n\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n数据库role表中的全部数据信息\n\n| id   | role_name   | note       |\n| ---- | ----------- | ---------- |\n| 1    | SUPER_ADMIN | 超级管理员 |\n| 2    | admin       | 管理员     |\n| 3    | user        | 用户       |\n| 4    | user2       | 用户2      |\n| 8    | user3       | 用户3      |\n| 9    | test        | 测试       |\n| 10   | test2       | 测试2      |\n| 11   | test3       | 测试3      |\n| 12   | test4       | 测试4      |\n| 13   | test5       | 测试5      |\n\n代码执行结果\n\n```\n===分页信息===\n当前页码：1\n每页显示数据数：5\n总数据数：10\n总页数：2\n=============\n===数据列表===\nRole{id=1, roleName='SUPER_ADMIN', note=' 超级管理员'}\nRole{id=2, roleName='admin', note='管理员'}\nRole{id=3, roleName='user', note='用户'}\nRole{id=4, roleName='user2', note='用户2'}\nRole{id=8, roleName='user3', note='用户3'}\n```\n\n打印的`SQL`信息\n\n```\n==>  Preparing: select count(*) as total from (SELECT id, role_name, note FROM role) $_paging \n==> Parameters: \n<==    Columns: total\n<==        Row: 10\n<==      Total: 1\n==>  Preparing: select * from (SELECT id, role_name, note FROM role) $_paging_table_limit limit ?, ? \n==> Parameters: 0(Integer), 5(Integer)\n<==    Columns: id, role_name, note\n<==        Row: 1, SUPER_ADMIN,  超级管理员\n<==        Row: 2, admin, 管理员\n<==        Row: 3, user, 用户\n<==        Row: 4, user2, 用户2\n<==        Row: 8, user3, 用户3\n<==      Total: 5\n```","tags":["MyBatis"]},{"title":"MySql-Transaction-Isolation-Level","url":"/2022/03/09/MySql-Transaction-Isolation-Level/","content":"\n\n\n# 事务的4大特性ACID\n原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。\n一致性（Consistent）：一方面，在事务开始之前和事务结束以后，数据库的完整性没有被破坏；另一方面，写入的数据必须完全符合所有的预设规则。\n隔离性（Isolation）：不同的会话或线程，操作数据库的时候可能产生多个事务。如果同时操作一张表或同一行数据，必然产生并发或干扰操作。隔离性要求事务间对表或数据操作是透明的，互相不存在干扰的，通过这种方式保证一致性。\n持久性（Durable）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n#  MySQL 事务的隔离级别\n\n\n\n## 准备环境\n\n```\n docker pull mysql\n docker run --name=mysql -it -p3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\n docker ps -a\n docker exec -it 15084 bash\n mysql -u root -p\n mysql> create database kangpan\n mysql> use kangpan\n\n```\n\n\n\n## 准备数据\n\n```\nmysql> create table user(\n    -> id int(10) auto_increment,\n    -> name varchar(30) default null,\n    -> age tinyint(4) default null,\n    -> primary key (id)\n    -> )engine=innodb charset=utf8mb4;\n\n insert into user(id, name, age) values (1,'kangpan',31);\n\nmysql> select * from user;\n+----+---------+------+\n| id | name    | age  |\n+----+---------+------+\n|  1 | kangpan |   31 |\n+----+---------+------+\n1 row in set (0.00 sec)\n```\n\n## 事务并发可能出现的情况\n\n#### 脏读（Dirty Read）\n\n一个事务读到了另一个未提交事务修改过的数据\n\n\n\n#### 幻读（Phantom）\n\n一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）\n\n\n\n#### 不可重复读（Non-Repeatable Read）\n\n一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现）\n\n\n\n#### 幻读（Phantom）\n\n一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）\n\n\n\n## 事务的隔离级别\n\nMySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。\n\nMySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。\n\n隔离级别比较：可串行化>可重复读>读已提交>读未提交\n\n隔离级别对性能的影响比较：可串行化>可重复读>读已提交>读未提交\n\n由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。\n\n#### 读未提交（READ UNCOMMITTED）\n\n在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。\n\n可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。\n\n#### 读已提交（READ COMMITTED）\n\n在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。\n\n读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。\n\n#### 可重复读（REPEATABLE READ）\n\n在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。\n\n提问：为什么上了写锁（写操作），别的事务还可以读操作？\n\n因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。\n\n#### 可串行化（SERIALIZABLE）\n\n各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。\n\n\n\n## 隔离级别的实现原理\n\n使用MySQL的默认隔离级别（可重复读）来进行说明。\n\n每条记录在更新的时候都会同时记录一条回滚操作（回滚操作日志undo log）。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。即通过回滚（rollback操作），可以回到前一个状态的值。\n\n假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。\n\n- read-view A : 回滚段 将 2 改成 1\n- read-view B : 回滚段 将 3 改成 2\n\n- read-view C : 当前值 4 \n\nread-view A -> read-view B -> read-view C\n\n当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。\n\n同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。\n\n提问：回滚操作日志（undo log）什么时候删除？\n\nMySQL会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。\n\n提问：什么时候不需要了？\n\n当系统里么有比这个回滚日志更早的read-view的时候。\n\n我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行**回滚**，在 MySQL 中，恢复机制是通过 **回滚日志（undo log）** 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 **回滚日志** 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。\n\n另外，MVCC 的实现依赖于：**隐藏字段、Read View、undo log**。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改\n\n## 查看当前会话隔离级别\n\n#### 方式1\n\n```\n命令：SHOW VARIABLES LIKE 'transaction_isolation';\n\nmysql> show variables like 'transaction_isolation';\n+-----------------------+--------------+\n| Variable_name  | Value |\n+-----------------------+--------------+\n| transaction_isolation | SERIALIZABLE |\n+-----------------------+--------------+\n```\n\n#### 方式2\n\n```\n命令：SELECT @@transaction_isolation;\n\nmysql> select @@transaction_isolation;\n+-------------------------+\n| @@transaction_isolation |\n+-------------------------+\n| SERIALIZABLE            |\n+-------------------------+\n\nmysql> select @@global.transaction_isolation;\n+--------------------------------+\n| @@global.transaction_isolation |\n+--------------------------------+\n| READ-UNCOMMITTED               |\n+--------------------------------+\n1 row in set (0.01 sec)\n```\n\n## 设置隔离级别\n\n#### 方式1：通过set命令\n\n```\nSET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;\n其中level有4种值：\nlevel: {\n     REPEATABLE READ\n   | READ COMMITTED\n   | READ UNCOMMITTED\n   | SERIALIZABLE\n}\n```\n\n##### 关键词：GLOBAL\n\n```\nSET GLOBAL TRANSACTION ISOLATION LEVEL level;\neg: set global transaction isolation level read uncommitted;\n* 只对执行完该语句之后产生的会话起作用\n* 当前已经存在的会话无效\n```\n\n##### 关键词：SESSION\n\n```\nSET SESSION TRANSACTION ISOLATION LEVEL level;\n* 对当前会话的所有后续的事务有效\n* 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务\n* 如果在事务之间执行，则对后续的事务有效。\n```\n\n##### 无关键词\n\n```\nSET TRANSACTION ISOLATION LEVEL level;\n* 只对当前会话中下一个即将开启的事务有效\n* 下一个事务执行完后，后续事务将恢复到之前的隔离级别\n* 该语句不能在已经开启的事务中间执行，会报错的\n```\n\n#### 方式2：通过服务启动项命令\n\n> 可以修改启动参数transaction-isolation的值\n>\n> 比方说我们在启动服务器时指定了--transaction-isolation=READ UNCOMMITTED，那么事务的默认隔离级别就从原来的REPEATABLE READ变成了READ UNCOMMITTED。\n\n\n\n## 关于事务日志\n\n关于事务日志的说明中，我们可以看得出来，只要修改的数据已经写入到日志并且持久化了，数据本身还没有写入磁盘时，即使断电了，系统在重启的时候依然会将数据恢复。那么我们再来看看官网给出的innodb_flush_log_at_trx_commit 参数的介绍\n- 为0时，如果MySQL挂了或宕机可能会有1秒数据的丢失。\n- 为1时， 只要事务提交成功，redo log记录就一定在硬盘里，不会有任何数据丢失。如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。\n- 为2时， 只要事务提交成功，redo log buffer中的内容只写入文件系统缓存（page cache）。如果仅仅只是MySQL挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。\n\n该属性主要是为数据库的ACID原则进行服务的，并且默认为1，但是实际情况下设置为2会提高很多的事务性能，设置1的时候，innodb的缓存会在事务提交或者每秒钟时都会进行磁盘的刷新操作，2的时候，innodb缓存会在提交事务时写入到事务日志但不会刷新磁盘，然后在每秒钟时进行磁盘刷新操作，2要比1提高很多性能，事务没有commit时，断电了，此时肯定数据是没有更新成功的，因为都还没有来得及写入事务日志，事务提交后，在写入事务日志的时候，发生断电，此时无论是参数的值是1还是2，都应该恢复不了数据了，每秒钟刷新磁盘时，发生断电，此时既然事务日志已经持久化了，那么重启后，数据是会自动恢复的。\n\n#### 刷盘时机\n\nInnoDB 存储引擎为 redo log 的刷盘策略提供了 innodb_flush_log_at_trx_commit 参数，它支持三种策略：\n\n- **0** ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作，后台线程进行刷盘\n- **1** ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）\n- **2** ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache\n\ninnodb_flush_log_at_trx_commit 参数默认为 1 ，也就是说当事务提交时会调用 fsync 对 redo log 进行刷盘\n\n另外，InnoDB 存储引擎有一个后台线程，每隔1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。也就是说，一个没有提交事务的 redo log 记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入redo log buffer 中，这些 redo log 记录会被后台线程刷盘。除了后台线程每秒1次的轮询操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。\n\n\n#### 日志存储方式\n硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的redo日志文件大小都是一样的。\n比如可以配置为一组4个文件，每个文件的大小是 1GB，整个 redo log 日志文件组可以记录4G的内容。\n它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，在个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint\n- write pos 是当前记录的位置，一边写一边后移\n- checkpoint 是当前要擦除的位置，也是往后推移\n每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。\n\n## 关于Autocommit\n\n当变量autocommit的值为ON时，代表自动提交开启，改为OFF则变为手动提交。在手动提交模式下，可以使用下面两种指令开启事务：\n\n\n```\nstart transaction;\nbegin;\n```\n\n结束事务的方式也有两种，事务确认提交\n```\ncommit;\nrollback;\n```\n\n```\nmysql> set @@autocommit=0;\n\nmysql> SHOW VARIABLES like '%autocommit%';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| autocommit    | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n## 悲观锁与乐观锁\n\n- **悲观锁**：悲观锁指对数据被意外修改持保守态度，依赖数据库原生支持的锁机制来保证当前事务处理的安全性，防止其他并发事务对目标数据的破坏或破坏其他并发事务数据，将在事务开始执行前或执行中申请锁定，执行完后再释放锁定。这对于长事务来讲，可能会严重影响系统的并发处理能力\n\n  ```\n  LOCK TABLES a WRITE;\n  INSERT INTO a VALUES (1,23),(2,34),(4,33);\n  INSERT INTO a VALUES (8,26),(6,29);\n  UNLOCK TABLES;\n  ```\n\n  锁定表可以加速用多个语句执行的INSERT操作，因为索引缓存区仅在所有INSERT语句完成后刷新到磁盘上一次。一般有多少INSERT语句即有多少索引缓存区刷新，如果能用一个语句插入所有的行，就不需要锁定；对于事务表，应使用BEGIN和COMMIT代替LOCK TABLES来加快插入\n\n- **乐观锁**：乐观锁相对悲观锁而言，先假想数据不会被并发操作修改，没有数据冲突，只在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则宣告失败，否则更新数据。这就要求避免使用长事务和锁机制，以免导致系统并发处理能力降低，保障系统生产效率。下面将说明使用乐观锁时的大致业务处理流程\n\n  ```\n  首 步：执行一次查询 select some_column as old_value from some_table where id = id_value (假设该值在当前业务处理过程中不会被其他并发事务修改)\n  ...\n  第n步：old_value参与中间业务处理，比如old_value被自己修改 new_value = f(old_value)。这期间可能耗时很长，但不会为持有 some_column 而申请所在的行或表锁定，因此其他并发事务可以获得该锁\n  ...\n  尾 步：执行条件更新 update some_table set some_column = new_value where id = id_value and some_column = old_value (条件更新中检查old_value是否被修改)\n  ```\n\n## 三大日志\nMySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。\nMySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。\n","tags":["MySql"]},{"title":"Run-Time-Data-Areas","url":"/2022/03/09/Run-Time-Data-Areas/","content":"\n\n\n## The pc Register - 程序计数器\n\n线程私有内存，保存**当前线程所执行的字节码的行号指示器**，这里和计算机组成原理中的计数器不太一样，计组中的 PC 指的是**下一条要执行的指令**的地址。JVM 中常有多个线程执行，故每条线程都需要有一个独立的程序计数器。\n\n如果线程执行的是 Java 方法，哪儿计数器记录的就是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，这个计数器则为空。\n\nP.S. 这块内存无OutOfMemoryError\n\n## Java Virtual Machine Stacks - Java 虚拟机栈\n\n线程私有，虚拟机栈描述的是 Java 方法执行的内存模型，每个方法在执行时会创建一个栈帧，栈帧中保存有局部变量表、操作数栈、动态链接和方法出口等。粗略来讲 Java 内存区分为堆和栈，实际上『栈』指的往往是虚拟机栈中的局部变量表部分。\n\n局部变量表中存放了编译期可知的各种基本数据类型、对象引用类型和 returnAddress 类型。方法运行期间局部变量表大小不变。\n\n## Native Method Stacks - 本地方法栈\n\n和虚拟机栈类似，不过区别在于虚拟机栈为 Java 方法（字节码）服务，而本地方法栈为 Native 方法服务（类似 C 语言中的栈）。具体实现可将这两者合二为一。\n\n## Heap - 堆\n\n堆是被所有线程共享的一块内存区域。一般来说所有的对象实例和数组都要在堆上分配，但一些优化技术导致不一定所有对象实例都在堆上分配。\n\n## Method Area - 方法区\n\n各线程共享的一块内存区域，和操作系统中进程中的『文本段』有些类似，用于存储虚拟机加载的类信息、常量、静态常量和即时编译器编译后的代码数据等。\n\n## Run-Time Constant Pool - 运行时常量池\n\n这一部分是方法区的一部分，用于保存 Class 文件中编译期生成的字面值和符号引用。\n\n## 直接内存\n\n这一部分并不是虚拟机运行时的数据区域，用于 Native 函数分配堆外内存，提高性能用（不必在操作系统堆和 Java 堆复制数据）。","tags":["Java"]},{"title":"Install-WSL","url":"/2022/03/09/Install-WSL/","content":"\n\n\n为简单起见，通常建议使用 [`wsl --install`](https://docs.microsoft.com/zh-cn/windows/wsl/install) 安装适用于 Linux 的 Windows 子系统，但如果运行的是旧版 Windows，则可能不支持这种方式。 下面介绍了手动安装步骤。 如果在安装过程中遇到问题，请查看[疑难解答指南的安装部分](https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting#installation-issues)。\n\n## 步骤 1 - 启用适用于 Linux 的 Windows 子系统\n\n需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。\n\n以管理员身份打开 PowerShell（“开始”菜单 >“PowerShell”> 单击右键 >“以管理员身份运行”），然后输入以下命令：\n\nPowerShell复制\n\n```powershell\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n```\n\n建议现在转到步骤 #2，更新到 WSL 2，但如果只想安装 WSL 1，现在可以重新启动计算机，然后继续执行[步骤 6 - 安装所选的 Linux 发行版](https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-6---install-your-linux-distribution-of-choice)。 若要更新到 WSL 2，请等待重新启动计算机，然后继续执行下一步。\n\n## 步骤 2 - 检查运行 WSL 2 的要求\n\n若要更新到 WSL 2，需要运行 Windows 10。\n\n- 对于 x64 系统：**版本 1903** 或更高版本，采用**内部版本 18362** 或更高版本。\n- 对于 ARM64 系统：**版本 2004** 或更高版本，采用**内部版本 19041** 或更高版本。\n- 低于 18362 的版本不支持 WSL 2。 使用 [Windows Update 助手](https://www.microsoft.com/software-download/windows10)更新 Windows 版本。\n\n若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。 更新到“设置”菜单中的[最新 Windows 版本](ms-settings:windowsupdate)。\n\n 备注\n\n如果运行的是 Windows 10 版本1903 或 1909，请在 Windows 菜单中打开“设置”，导航到“更新和安全性”，然后选择“检查更新”。 内部版本号必须是 18362.1049+ 或 18363.1049+，次要内部版本号需要高于 .1049。 阅读详细信息：[WSL 2 即将支持 Windows 10 版本 1903 和 1909](https://devblogs.microsoft.com/commandline/wsl-2-support-is-coming-to-windows-10-versions-1903-and-1909/)。\n\n## 步骤 3 - 启用虚拟机功能\n\n安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要[虚拟化功能](https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting#error-0x80370102-the-virtual-machine-could-not-be-started-because-a-required-feature-is-not-installed)才能使用此功能。\n\n以管理员身份打开 PowerShell 并运行：\n\nPowerShell复制\n\n```powershell\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n```\n\n**重新启动**计算机，以完成 WSL 安装并更新到 WSL 2。\n\n## 步骤 4 - 下载 Linux 内核更新包\n\n1. 下载最新包：\n\n   - [适用于 x64 计算机的 WSL2 Linux 内核更新包](https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi)\n\n    备注\n\n   如果使用的是 ARM64 计算机，请下载 [ARM64 包](https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_arm64.msi)。 如果不确定自己计算机的类型，请打开命令提示符或 PowerShell，并输入：`systeminfo | find \"System Type\"`。 **Caveat：** 在非英文版 Windows 上，你可能必须修改搜索文本，对“System Type”字符串进行翻译。 你可能还需要对引号进行转义来用于 find 命令。 例如，在德语版中使用 `systeminfo | find '\"Systemtyp\"'`。\n\n2. 运行上一步中下载的更新包。 （双击以运行 - 系统将提示你提供提升的权限，选择“是”以批准此安装。）\n\n安装完成后，请继续执行下一步 - 在安装新的 Linux 分发时，将 WSL 2 设置为默认版本。 （如果希望将新的 Linux 安装设置为 WSL 1，请跳过此步骤。）\n\n 备注\n\n有关详细信息，请参阅 [Windows 命令行博客](https://aka.ms/cliblog)上的文章[对更新 WSL2 Linux 内核的更改](https://devblogs.microsoft.com/commandline/wsl2-will-be-generally-available-in-windows-10-version-2004)。\n\n## 步骤 5 - 将 WSL 2 设置为默认版本\n\n打开 PowerShell，然后在安装新的 Linux 发行版时运行以下命令，将 WSL 2 设置为默认版本：\n\nPowerShell复制\n\n```powershell\nwsl --set-default-version 2\n```\n\n## 步骤 6 - 安装所选的 Linux 分发\n\n1. 打开 [Microsoft Store](https://aka.ms/wslstore)，并选择你偏好的 Linux 分发版。\n","tags":["WSL"]},{"title":"Hexo-Theme-AirCloud","url":"/2022/03/09/Hexo-Theme-AirCloud/","content":"\n\n\n## Hexo-Theme-AirCloud: 一个简洁轻量的 hexo 博客主题\n\n## 功能简介\n\nHexo-Theme-AirCloud 是一个简洁轻量的 hexo 博客主题，旨在将中心放在博文本身，因此：\n\n- 默认没有大范围的主题色块、图片铺排等，也不要求每片博文配图，一方面这并不是我们记录知识的重点，另外一方面可能程序员群体并没有足够的素材，容易造成主题纠纷。\n- 建议通过不冗余的内容进行传达，比如默认没有博文摘要，因为不少开发者写博客的时候没有写博文摘要，如果从博客前一部分截取往往不能表达完整思想。\n\n另外，该主题主要实现的功能有:\n\n- 全局搜索功能，并对搜索内容进行高亮。\n- 博客评论功能，目前接入 [gitment](https://imsun.net/posts/gitment-introduction/)，之后考虑接入多种可选。\n- 文章详情页文章目录功能\n- 访问量统计（总体UV、PV，单页PV）\n- 语言切换能力，目前支持中文和英文\n\n## 起步\n\n> 我在”常见问题”中总结了该项目之前被提及的一些问题，如果你在使用过程中遇到了问题，可以在”常见问题”中寻找答案，如果没能解决，欢迎提[issue](https://github.com/aircloud/hexo-theme-aircloud/issues)，我会保证回复。\n\n注意，如果你不按照”功能适配”部分的内容进行操作，可能会导致相关提及的功能无法正常使用。\n\n- [基本使用](https://github.com/aircloud/hexo-theme-aircloud#基本使用)\n- 功能适配\n  - [搜索功能](https://github.com/aircloud/hexo-theme-aircloud#搜索功能)\n  - [`标签`页面 & `关于`页面](https://github.com/aircloud/hexo-theme-aircloud#标签页面--关于页面)\n  - [评论功能](https://github.com/aircloud/hexo-theme-aircloud#评论功能)\n  - [favicon 的配置](https://github.com/aircloud/hexo-theme-aircloud#标签页面--关于页面)\n  - [底部自定义](https://github.com/aircloud/hexo-theme-aircloud#底部自定义)\n- 高级自定义\n  - [首行缩进](https://github.com/aircloud/hexo-theme-aircloud#首行缩进)\n- 常见问题\n  - [如何取消赞赏功能？](https://github.com/aircloud/hexo-theme-aircloud#如何取消赞赏功能)\n- [一些注意事项](https://github.com/aircloud/hexo-theme-aircloud#一些注意事项)\n\n## 基本使用\n\n**建议：参考 [DEMO](https://github.com/aircloud/hexo-aircloud-blog) 进行配置，尤其是 _config.yml 部分，否则可能会造成功能缺失**\n\n同其他博客主题使用方式相同，直接 clone 或者下载本项目，复制粘贴到 themes 文件夹下即可。\n\n具体的 _config.yml 自定义配置，请参考[DEMO](https://github.com/aircloud/hexo-aircloud-blog)。\n\n## 功能适配\n\n### 搜索功能\n\n为了使用搜索功能，首先需要安装下列插件：\n\n```\nnpm i hexo-generator-search --save\n```\n\n然后在 _config.yml 中进行配置，可以参考如下配置：\n\n```\nsearch:\n  path: search.json\n  field: post\n```\n\n### `标签`页面 & `关于`页面\n\n如果是新项目，默认是没有`标签`页面和`关于`页面的，需要在`source`文件夹下建立`tags`文件夹和`about`文件夹。\n\n> 注：建议不要直接新建文件，而是采用 hexo 的 `hexo new page tags` 和 `hexo new page about` 的方式新建文件，这样可以被 hexo 索引到。\n\n其中`tags`文件夹中新建`index.md`并写入：\n\n```\n---\nlayout: \"tags\"\ntitle: \"Tags\"\n---\n```\n\n`about`文件夹下`index.md`为一篇支持 markdown 格式的文件，需要在开头添加：\n\n```\n---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ncomments: true\n---\n```\n\n### 评论功能\n\n目前，本博客支持以下评论功能：\n\n- [gitment](https://imsun.net/posts/gitment-introduction/)（gitment 经常会出现限频或者 404 等错误，其作者已关闭github认证转发服务）\n- [disqus](https://disqus.com/)\n- [LiveRe](https://www.livere.com/)\n\n#### gitment\n\n建议先在[gitment](https://imsun.net/posts/gitment-introduction/)进行了解，然后参考[DEMO](https://github.com/aircloud/hexo-aircloud-blog)进行配置，其中一些相关项目如下：\n\n```\ncomment:\n  type: gitment\n  id: your-id-created-by-https://github.com/settings/applications/new\n  secret: your-secret-created-by-https://github.com/settings/applications/new\n  owner: aircloud\n  repo: hexo-aircloud-blog\n```\n\n#### disqus\n\ndisqus 是一个使用比较广泛的评论系统，我们需要先在[官方网站](https://disqus.com/)注册一个账号。\n\n登录后，点击首页的 GET STARTED 按钮，之后选择 I want to install Disqus on my site 选项，填写相关内容，值得注意的是，`Website Name` 需要全网唯一，而且，一般情况，假设你的 `Website Name` 填写的是 example，那么下文 `script` 字段就可以写 `'https://example.disqus.com/embed.js'`。\n\n当然，你也可以在下一步 -> 选择 basic 免费套餐 -> 选择最后的 “I don’t see my platform listed, installed manually with universal code” -> 找到代码中的 `s.src = 'https://xxxx.disqus.com/embed.js'; `, 从而找到 script 地址。(无需插入 disqus 给出的脚本，只需按照这里的说明配置即可)\n\n之后，你需要在 `_config.yml` 中配置如下内容：\n\n```\ncomment:\n   type: disqus\n   script: 'https://example.disqus.com/embed.js'\n```\n\n当然，你也可以配置`url` 和 `identifier`， 但是这个就属于高级内容了，对于我们一般的 hexo 博客网站来说必要性不大，如果你需要配置这些内容，可能你已经是一个高级玩家了，可以在 `themes/aircloud/layout/layout.ejs` 的相关代码的基础上进行改动。\n\n> 注意: 目前，直接嵌入 disqus 的代码可能会加载失败，你也可以考虑将相关代码放在自己的博客下引入：在 public 文件夹下新建文件放入代码，跟随发布即可（放入 source 文件夹下可能会由于 hexo 的处理变得有错误），并同时更改 `_config.yml` 中的配置。\n\n#### LiveRe\n\nLiveRe 是一款来自韩国的支持中文且没有被墙LiveRe评论插件，重点是使用无需翻墙。\n\n该插件分为city和premium两个版本，其中city版是适合所有人使用的免费版本,有更高需求的可以考虑premium版本。\n\n注册之后，选择 安装 -> 选 city版本，按提示操作进入到管理页面，系统会给出一段嵌入代码，找到其中的data-id和data-uid。\n\n之后，你需要在`_config.yml`中配置如下内容\n\n```\ncomment:\n   type: livere\n   livere_id: 'city'\n   livere_uid: \n```\n\n`livere_id` 和 `livere_uid`就是注册后获得的 data-id和data-uid。\n\n### favicon 的配置\n\n项目的 favicon 默认在你的博客根目录的 `/source/img` 下面，在 `/source/img` 下面添加 favicon.ico 即可，不要添加在主题文件夹内。\n\n### 底部自定义\n\n大家如果访问提供的预览链接，会发现我们的博客底部是提供一些内容的：一些社交平台的个人主页链接、友情链接、PV、UV 与 本模版链接。\n\n一般情况下，大家无需改动底部的代码，直接在 `_config.yml` 中配置即可。\n\n配置社交平台主页的样例代码：\n\n```\n# SNS settings\n# 一些社交平台地址，支持以下几种：\nweibo_username:     3286578617\nzhihu_username:     ai-er-lan-xue-da\ngithub_username:    AirCloud\ntwitter_username:   iconie_alloy\nfacebook_username:  xiaotao.nie.5\nlinkedin_username:  小涛-聂-80964aba\n```\n\n如果不想包括某些社交平台，直接注释或删除相关代码即可（目前暂不支持在不改动模版代码的前提下新增社交平台）。\n\n配置友情链接的样例代码：\n\n```\n# Friends\n# 友情链接\nfriends: [\n    {\n        title: \"10000H\",\n        href: \"https://www.10000h.top\"\n    },{\n        title: \"Xiaotao's Page\",\n        href: \"https://niexiaotao.com\"\n    },{\n        title: \"It helps SEO\",\n        href: \"#\"\n    }\n]\n```\n\n最底部的 PV、UV 和模版地址，无需配置。\n\n## 高级自定义\n\n### 首行缩进\n\n目前可以配置是否在博客页面带有首行缩进两个汉字的效果，默认是有首行缩进的效果的，但是也可以通过下面的配置代码进行关闭：\n\n```\npost_style:\n    indent: 0\n```\n\n### 头像圆角\n\n```\navatar_style:\n  radius: true\n```\n\n## 常见问题\n\n### 如何取消赞赏功能？\n\n目前网站的赞赏功能做的比较鸡肋，缺乏一定的丰富度，如果你想取消这个功能，只需取消注释或者删除掉赞赏部分的相关配置即可：\n\n```\ndonate:\n  img: img/donate.jpg\n  content: 感谢鼓励\n```\n\n另外，如果你对赞赏部分有用户体验较好并且通用型比较好的设计，也可以提 issue，我会考虑实现。\n\n## 一些注意事项\n\n由于一些hexo的历史遗留问题等，为了避免给用户在使用过程中带来太多麻烦(比如需要改动主题代码甚至hexo源码)，建议用户使用过程中遵循一些规范：\n\n- 文章不要有跳级目录，比如一个`###`三级目录下是一个`#####`五级目录，然后又有一个`###`三级目录，这样有可能导致 hexo 解析出错，从而影响文章目录部分的展示。\n- 文章的段落(p)都有默认的两个字符的首行缩进，虽然能识别 markdown 段落中的换行，但是无法对换行后的内容进行缩进，所以这里需要注意样式问题(如果需要多行缩进，建议使用多个段落或者做成列表)。\n","tags":["Hexo"]}]