[{"title":"Java线程池 工作窃取算法","url":"/2022/03/18/Java线程池-工作窃取算法/","content":"\n# 前言\n\n在上一篇《java线程池,阿里为什么不允许使用Executors?》中我们谈及了线程池，同时又发现一个现象，当最大线程数还没有满的时候耗时的任务全部堆积给了单个线程, 代码如下:\n\n```\nThreadPoolExecutor executor = new ThreadPoolExecutor(\n        1, //corePoolSize\n        100, //maximumPoolSize\n        100, //keepAliveTime\n        TimeUnit.SECONDS, //unit\n        new LinkedBlockingDeque<>(100));//workQueue\n\nfor (int i = 0; i < 5; i++) {\n    final int taskIndex = i;\n    executor.execute(() -> {\n        System.out.println(taskIndex);\n        try {\n            Thread.sleep(Long.MAX_VALUE);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n}\n// 输出: 0\n```\n\n那么有没有一种机制，在线程池中还有线程可以提供服务的时候帮忙分担一些已经被分配给某一个线程的耗时任务呢？\n答案当然是有的：**工作窃取算法**\n\n# 工作窃取 (Work stealing)\n\n**工作窃取核心思想是，自己的活干完了去看看别人有没有没干完的活，如果有就拿过来帮他干。**\n大多数实现机制是：**为每个工作者程分配一个双端队列(本地队列)用于存放需要执行的任务，当自己的队列没有数据的时候从其它工作者队列中获得一个任务继续执行。**\n\n比如工作者B的本地队列中没有了需要执行的规则，它正尝试从工作者A的任务队列中偷取一个任务。\n\n> 为什么说尝试？因为涉及到并行编程肯定涉及到并发安全的问题，有可能在偷取过程中工作者A提前抢占了这个任务，那么B的偷取就会失败。大多数实现会尽量避免发生这个问题，所以大多数情况下不会发生。\n\n## 并发安全的问题是怎么避免的呢？\n\n一般是自己的本地队列采取LIFO(后进先出)，偷取时采用FIFO(先进先出)，一个从头开始执行，一个从尾部开始执行，由于偷取的动作十分快速，会大量降低这种冲突，也是一种优化方式。\n\n# Java中的工作窃取算法线程池\n\n在Java 1.7新增了一个ForkJoinPool类，主要是实现了工作窃取算法的线程池，该类在1.8中被优化了，同时1.8在Executors类中还新增了两个newWorkStealingPool工厂方法。\n\n> java7中的fork/join task 和 java8中的并行stream都是基于ForkJoinPool。\n\n```\n// 使用当前处理器数, 相当于调用 newWorkStealingPool(Runtime.getRuntime().availableProcessors());\npublic static ExecutorService newWorkStealingPool();\npublic static ExecutorService newWorkStealingPool(int parallelism);\n```\n\n同时 ForkJoinPool 还在全局建立了一个公共的线程池\n\n```\nForkJoinPool.commonPool();\n```\n\n默认的并行度是当前JVM识别到的处理器数。这个值也是可以通过参数进行变更的，下面是可以通过JVM熟悉进行commonPool设置的参数。\n\n> 前缀统一为: java.util.concurrent.ForkJoinPool.common.\n> 比如 parallelism 就要写为 java.util.concurrent.ForkJoinPool.common.parallelism\n\n| 参数             | 描述               | 默认值                                          |\n| :--------------- | :----------------- | :---------------------------------------------- |\n| parallelism      | 并行级别           | JVM识别到的处理器数                             |\n| threadFactory    | 线程工厂类名       | ForkJoinPool.DefaultForkJoinWorkerThreadFactory |\n| exceptionHandler | 错误处理程序       | null                                            |\n| maximumSpares    | 最大允许额外线程数 | 256                                             |\n\n使用工作窃取算法的线程池来优化之前的代码\n\n```\nExecutorService executor = Executors.newWorkStealingPool(8);\n\nfor (int i = 0; i < 5; i++) {\n    final int taskIndex = i;\n    executor.execute(() -> {\n        System.out.println(taskIndex);\n        try {\n            Thread.sleep(Long.MAX_VALUE);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n}\n\n// 无序输出 0~4\n```\n\n### 如果将Executors.newWorkStealingPool(8)改成ForkJoinPool.commonPool()会输出什么？\n\n如果你能知道输出什么那么你对这个机制就算掌握了，会输出当前运行环境中处理器（cpu）数量的次数（如果核算大于5就只会输出5个结果）。\n\n## newWorkStealingPool 和 ForkJoinPool.commonPool 该优先选择哪个？\n\n这个没有最优解，推荐执行的小任务（零散的）使用commonPool，而有特定目的的则使用newWorkStealingPool或 new ForkJoinPool。\n\n## 使用ForkJoinPool.commonPool 需要注意的问题\n\ncommonPool默认使用当前环境的处理器格式来当做并行程度，如果遇上堵塞形任务一样会遇到浪费算力的问题。\n这点在容器化时需要特别注意，因为容器化的cpu个数限制往往不会太大。\n这种时候可以通过设置默认的并行度或者使用newWorkStealingPool来手动指定并行度。\n\n# 最后\n\n## 为什么ForkJoinPool极少出现线程关键字？\n\n现在许多语言淡化了线程这个概念，而golang中更是直接去掉了线程能力改为提供协程goroutine。\n目的还是线程是OS的资源，OS对程序内部运行其实并没有太了解，为了避免线程资源的浪费许多语言会自己管理线程。\n对于程序来说我们关心的主要还是任务的并行运行，并不关心是线程还是协程。\n下面是一些对应关系：\n\n- CPU : 线程 (1:N)\n- 线程 : 协程 (1:N)\n\n> CPU由OS管理，OS提供线程给程序使用，程序利用线程提供协程能力给应用使用。\n\n## ForkJoinPool一定更快吗？\n\n不，大家都知道做的事情越多逻辑越复杂效率会越低。\nForkJoinPool中的工作队列，工作窃取都是需要额外管理的，同时也对线程调度和GC带来了压力。\n所以ForkJoinPool并不是万能药大家根据具体需要去使用。\n\n","tags":["Java"]},{"title":"java线程池 阿里为什么不允许使用Executors?","url":"/2022/03/18/java线程池-阿里为什么不允许使用Executors/","content":"\n# 带着问题\n\n1. 阿里Java代码规范为什么不允许使用Executors快速创建线程池？\n2. 下面的代码输出是什么？\n\n```\nThreadPoolExecutor executor = new ThreadPoolExecutor(\n        1, //corePoolSize\n        100, //maximumPoolSize\n        100, //keepAliveTime\n        TimeUnit.SECONDS, //unit\n        new LinkedBlockingDeque<>(100));//workQueue\n\nfor (int i = 0; i < 5; i++) {\n    final int taskIndex = i;\n    executor.execute(() -> {\n        System.out.println(taskIndex);\n        try {\n            Thread.sleep(Long.MAX_VALUE);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n}\n```\n\n> A) 0 1 2 3 4 5\n> B) 0~5 顺序不一致输出5行\n> C) 0\n\n# 基础\n\n## 什么是线程池？\n\n线程池可以通过池看出来是一个资源集，任何池的作用都大同小异，主要是用来减少资源创建、初始化的系统开销。\n\n### 创建线程很“贵”吗？\n\n是的。创建线程的代价是昂贵的。\n\n我们都知道系统中的每个进程有自己独立的内存空间，而被称为轻量级进程的线程也是需要的。\n\n在JVM中默认一个线程需要使用256k~1M（取决于32位还是64位操作系统）的内存。（具体的数组我们不深究，因为随着JVM版本的变化这个默认值随时可能发生变更，我们只需要知道线程是需要占用内存的）\n\n**除了内存还有更多吗？**\n许多文章会将上下文切换、CPU调度列入其中，这边不将线程调度列入是因为睡眠中的线程不会被调度（OS控制），如果不是睡眠中的线程那么是一定需要被调度的。\n但在JVM中除了创建时的内存消耗，还会给GC带来压力，如果频繁创建线程那么相对的GC的时候也需要回收对应的线程。\n\n### 线程池的机制？\n\n可以看到线程池是一种重复利用线程的技术，线程池的主要机制就是保留一定的线程数在没有事情做的时候使之睡眠，当有活干的时候拿一个线程去运行。\n这些牵扯到线程池实现的具体策略。\n\n### 还有哪些常见的池？\n\n- 线程池\n- 连接池（数据库连接、TCP连接等）\n- BufferPool\n- ......\n\n# Java中的线程池\n\n## UML图（Java 8）\n可以看到真正的实现类有\n\n1. ThreadPoolExecutor (1.5)\n2. ForkJoinPool (1.7)\n3. ScheduledThreadPoolExecutor (1.5)\n\n今天我们主要谈谈 ThreadPoolExecutor 也是使用率较高的一个实现。\n\n## Executors提供的工厂方法\n\n1. newCachedThreadPool (ThreadPoolExecutor)\n\n> 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程,那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。\n\n1. newFixedThreadPool (ThreadPoolExecutor)\n\n> 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。\n\n1. newSingleThreadExecutor (ThreadPoolExecutor)\n\n> 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。\n\n1. newScheduledThreadPool (ScheduledThreadPoolExecutor)\n\n> 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\n1. newSingleThreadScheduledExecutor (ScheduledThreadPoolExecutor)\n\n> 创建一个单线程用于定时以及周期性执行任务的需求。\n\n1. newWorkStealingPool (1.8 ForkJoinPool)\n\n> 创建一个工作窃取\n\n可以看到各种不同的工厂方法中使用的线程池实现类最终只有3个，对应关系如下：\n\n| 工厂方法                         | 实现类                      |\n| :------------------------------- | :-------------------------- |\n| newCachedThreadPool              | ThreadPoolExecutor          |\n| newFixedThreadPool               | ThreadPoolExecutor          |\n| newSingleThreadExecutor          | ThreadPoolExecutor          |\n| newScheduledThreadPool           | ScheduledThreadPoolExecutor |\n| newSingleThreadScheduledExecutor | ScheduledThreadPoolExecutor |\n| newWorkStealingPool              | ForkJoinPool                |\n\n## ThreadPoolExecutor\n\n首先我们看下 ThreadPoolExecutor 的完全构造函数\n\n```\npublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n```\n\n1. corePoolSize\n\n> 核心池大小，除非设置了 allowCoreThreadTimeOut 否则哪怕线程超过空闲时间，池中也要最少要保留这个数目的线程。\n>\n> 需要注意的是，corePoolSize所需的线程并不是立即创建的，需要在提交任务之后进行创建，所以如果有大量的缓存线程数可以先提交一个空任务让线程池将线程先创建出来，从而提升后续的执行效率。\n\n1. maximumPoolSize\n\n> 允许的最大线程数。\n\n1. keepAliveTime\n\n> 空闲线程空闲存活时间，核心线程需要 allowCoreThreadTimeOut 为true才会退出。\n\n1. unit\n\n> 与 keepAliveTime配合，设置 keepAliveTime的单位，如：毫秒、秒。\n\n1. workQueue\n\n> 线程池中的任务队列。上面提到线程池的主要作用是复用线程来处理任务，所以我们需要一个队列来存放需要执行的任务，在使用池中的线程来处理这些任务，所以我们需要一个任务队列。\n\n1. threadFactory\n\n> 当线程池判断需要新的线程时通过线程工程创建线程。\n\n1. handler\n\n> 执行被阻止时的处理程序，线程池无法处理。这个与任务队列相关，比如队列中可以指定队列大小，如果超过了这个大小该怎么办呢？JDK已经为我们考虑到了，并提供了4个默认实现。\n\n下列是JDK中默认携带的策略:\n\n1. AbortPolicy (默认)\n\n> 抛出 RejectedExecutionException 异常。\n\n1. CallerRunsPolicy\n\n> 调用当前线程池所在的线程去执行。\n\n1. DiscardPolicy\n\n> 直接丢弃当前任务。\n\n1. DiscardOldestPolicy\n\n> 将最旧的任务丢弃，将当前任务添加到队列。\n\n容易混淆的参数：corePoolSize maximumPoolSize workQueue\n\n### 任务队列、核心线程数、最大线程数的逻辑关系\n\n1. 当线程数小于核心线程数时，创建线程。\n2. 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。\n3. 当线程数大于等于核心线程数，且任务队列已满\n   1. 若线程数小于最大线程数，创建线程\n   2. 若线程数等于最大线程数，调用拒绝执行处理程序（默认效果为：抛出异常，拒绝任务）\n\n### 那么这三个参数推荐如何设置，有最优值吗？\n\n由于java对于协程的支持不友好，所以会大量依赖于线程池和线程。\n从而这个值没有最优推荐，需要根据业务需求情况来进行设置。\n不同的需求类型可以创建多个不同的线程池来执行。\n\n## 问题1：阿里开发规范为什么不允许Executors快速创建线程池？\n\n> 参考地址：https://github.com/alibaba/p3c\n\n可以看到原因很简单\n\n1. newSingleThreadExecutor\n2. newFixedThreadPool\n\n在 workQueue 参数直接 使用了 new LinkedBlockingQueue<Runnable>() 理论上可以无限添加任务到线程池。\n\n```\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>();\n}\n\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1,\n    1,\n    0L,\n    TimeUnit.MILLISECONDS,\n    new LinkedBlockingQueue<Runnable>()));\n}\n```\n\n如果提交到线程池的任务由问题，比如 sleep 永久，会造成内存泄漏，最终导致OOM。\n\n同时 阿里还推荐自定义 threadFactory 设置线程名称便于以后排查问题。\n\n## 问题2：下面的代码输出是什么？\n\n应该选C。\n虽然最大线程数有100但核心线程数为1，任务队列由100。\n满足了 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列，这个条件。\n所以后续添加的任务都会被堵塞。\n\n# 最后\n\n关于 ThreadPoolExecutor 的逻辑在实际使用的时候会有点奇怪，因为线程池中的线程并没有超过最大线程数，有没有一种可能当任务被堵塞很久的时候创建新的线程池来处理呢？\n\n这边推荐大家使用 newWorkStealingPool，也就是ForkJoinPool。采取了工作窃取的模式。\n","tags":["Java"]},{"title":"WordCounter","url":"/2022/03/18/WordCounter/","content":"\n```\nimport java.util.Spliterator;\nimport java.util.function.Consumer;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\n/**\n * 计算单词个数\n * <U> U reduce(U identity,\n * BiFunction<U, ? super T, U> accumulator,\n * BinaryOperator<U> combiner);\n */\npublic class WordCounter {\n    private final boolean lastSpace;\n    private final int count;\n\n    public WordCounter(boolean lastSpace, int count) {\n        this.lastSpace = lastSpace;\n        this.count = count;\n    }\n\n    /**\n     * 和迭代算法一样 ，\n     * accumulate 方法一\n     * 个个遍历Character\n     *\n     * @param character\n     * @return\n     */\n    public WordCounter accumulator(Character character) {\n        if (Character.isWhitespace(character)) {\n            return lastSpace ? this : new WordCounter(true, count);\n        } else {\n            return lastSpace ? new WordCounter(false, count + 1) : this;\n        }\n    }\n\n    /**\n     * 合并两个Word Counter，把其\n     * 计数器加起来\n     *\n     * @param wordCounter\n     * @return\n     */\n    public WordCounter combiner(WordCounter wordCounter) {\n        return new WordCounter(lastSpace, count + wordCounter.count);\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public static void main(String[] args) {\n        String str = \" Nel mezzo del cammin di nostra vita \" +\n                \"mi ritrovai in una selva oscura\" +\n                \" ché la dritta via era smarrita \";\n        Stream<Character> characterStream = IntStream.range(0, str.length()).mapToObj(str::charAt);\n        System.out.println(countWordsIteratively(characterStream));\n        Spliterator<Character> spliterator = new WordCounterSpliterator(str);\n        Stream<Character> characterSpliteratorStream = StreamSupport.stream(spliterator, true);\n        System.out.println(countWordsIteratively(characterSpliteratorStream.parallel()));\n        System.out.println(countWordsIteratively(str));\n\n\n    }\n\n    public static int countWordsIteratively(Stream<Character> characterStream) {\n        WordCounter wordCounter =\n                characterStream.reduce(\n                        new WordCounter(true, 0), WordCounter::accumulator, WordCounter::combiner);\n        return wordCounter.getCount();\n    }\n\n    public static int countWordsIteratively(String str) {\n        boolean lastSpace = true;\n        int count = 0;\n        char[] chars = str.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            if (Character.isWhitespace(chars[i])) {\n                lastSpace = true;\n            } else {\n                if (lastSpace) count++;\n                lastSpace = false;\n            }\n        }\n        return count;\n    }\n\n    public static class WordCounterSpliterator implements Spliterator<Character> {\n\n        private final String string;\n        private int currentChar = 0;\n\n        public WordCounterSpliterator(String string) {\n            this.string = string;\n        }\n\n        /**\n         * tryAdvance方法的行为类似于普通的\n         * Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且如果还有其他元素要遍\n         * 历就返回true。\n         *\n         * @param action\n         * @return\n         */\n        @Override\n        public boolean tryAdvance(Consumer<? super Character> action) {\n            action.accept(string.charAt(currentChar++));\n            return currentChar < string.length();\n        }\n\n        /**\n         * 但trySplit是专为Spliterator接口设计的，因为它可以把一些元素划出去分\n         * 给第二个Spliterator（由该方法返回），让它们两个并行处理。\n         * 如果你需要执行拆分，就把试探的拆分位置设在要解析的String块的中间。但我\n         * 们没有直接使用这个拆分位置，因为要避免把词在中间断开，于是就往前找，直到找到\n         * 一个空格。一旦找到了适当的拆分位置，就可以创建一个新的Spliterator来遍历从\n         * 当前位置到拆分位置的子串；\n         *\n         * @return\n         */\n        @Override\n        public Spliterator<Character> trySplit() {\n            int currentSize = string.length() - currentChar;\n            if (currentSize < 10) {\n                return null;\n            }\n            for (int splitPos = currentSize / 2 + currentChar; splitPos < string.length(); splitPos++) {\n                if (Character.isWhitespace(string.charAt(splitPos))) {\n                    Spliterator<Character> spliterator =\n                            new WordCounterSpliterator(string.substring(currentChar, splitPos));\n                    currentChar = splitPos;\n                    return spliterator;\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Spliterator还可通过\n         * estimateSize方法估计还剩下多少元素要遍历，因为即使不那么确切，能快速算出来是一个值\n         * 也有助于让拆分均匀一点。\n         * 还需要遍历的元素的estimatedSize就是这个Spliterator解析的String的总长度和\n         * 当前遍历的位置的差。\n         *\n         * @return\n         */\n        @Override\n        public long estimateSize() {\n            return string.length() - currentChar;\n        }\n\n        /**\n         * Spliterator是ORDERED（顺序就是String\n         * 中各个Character的次序）、SIZED（estimatedSize方法的返回值是精确的）、\n         * SUBSIZED（trySplit方法创建的其他Spliterator也有确切大小）、NONNULL（String\n         * 中不能有为 null 的 Character ） 和 IMMUTABLE （在解析 String 时不能再添加\n         * Character，因为String本身是一个不可变类）的\n         *\n         * @return\n         */\n        @Override\n        public int characteristics() {\n            return ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;\n        }\n    }\n}\n```\n\n","tags":["Design"]},{"title":"俞敏洪在同济大学的的演讲","url":"/2022/03/17/俞敏洪在同济大学的的演讲/","content":"\n同济大学的同学们大家晚上好！ \n\n\n  其实人活着就挺好，至于生命有没有意义另当别论。活着每天都会有太阳升起来，每天都会看到太阳落下去。你就可以看到朝霞，看到晚霞，看到月亮升起和落下，看到满天的繁星，这就是活着的最美好的意义所在。 \n\n\n  没想到同济大学的同学们把我如此“高大”的形象放在大屏幕上，这就是理想与现实的差距。所以我相信同学们看到我的第一眼一定感到非常的失望。实际上，每一 个人都是非常普通的，我们很多时候会发现生命中非常重要的东西跟我们未来的幸福和成功其实没有太多的联系。比如，有人认为，相貌跟未来的成功会有很多的联 系；有人认为，自己的家庭背景会跟成功有必然的联；有人认为，上名牌大学的人会成功，在大学里成绩好的人比学习成绩差的人更加容易取得成功……所有这些因 素可能有部分是对的，但大部分基本无效，比如说相貌。 \n\n\n  如果说一个人的相貌和成功有关，那就不会有马云和阿里巴巴，因为如果在座的同学认为马云长得好看，那一定是审美出了问题。 \n\n\n  当然，这并不意味着相貌好看的人就做不成事情，比如说，另外一位大家比较熟悉的公司老总百度老总李彦宏。李彦宏非常英俊潇洒，他所有的照片看上去都像电 影明星一样，但是他也取得了成功。所以不管相貌如何，都能取得成功，只不过李彦宏和马云坐在一起吃饭的时候，他们通常不太愿意坐在相邻的椅子上，因为两个 人的对照到了惨不忍睹的地步，解决的方法就是把我放到他们两个中间，起到一个过渡的作用。像我这样，相貌没有什么特点的人也能取得成功。所以不管是男是 女，最重要的是自己内心世界的丰富，自己风度和气质的培养，自己胸怀的扩展以及对理想目标坚定不移的追求。随着年龄的增加，这些会慢慢变成你的智慧，所有 这一切才是构成你成功的真正的本质。 \n\n\n  那么成功和家庭背景有没有关系呢？我们常可以看到一些权贵富贾出身的人，他们一出生就含着金钥匙。比如，我们可能会看到，自己左边的一些同学穿着名牌服 装，右边的拎着名牌的皮包，前面坐着市委书记的女儿，后面坐着中央领导的儿子，而你可能就一个来自普通工人家庭的大学生。 \n\n\n  有的时候你会心存不满，但这个世界本来就充满着不公平，而很多不公平常常就在你的眼前闪现。你会说，这个世界怎么会对我这样，为什么他什么都有，而我什么 都没有？我在大学里也有过这种很正常的心理。比如，我的同学有部长的儿子、有大学教授的女儿，而我却是一个农民的儿子。3次高考后才走进了北京大学，穿着 布衣挑着扁担走进去的。你会发现你总赶不上他们的状态，倒不如说赶不上他们的脚步。你会发现即使他们停下来一辈子什么都不做，他们所拥有的东西都比你 多。 \n\n\n  比如，在大学一年级的时候，班上那个部长的孩子每周五都有开着奔驰280的司机把他接回去。你想我们那个时候连自行车都买不起，他居然坐着奔驰280，那 是一种什么样的感觉。你感到这辈子基本就完蛋了。但是同学们你们要记住一个真理，生命总是往前走的，我们要走一辈子。我们既不是只走过大学四年，或研究 生，我们要走一辈子。可能走到80、90岁，虽然走到80、90岁时，人生到底怎么样你是不知道的，你惟一能做的就是要坚持走下去。所以我非常骄傲地从一 个农民的儿子走到北大最后又走到了今天。我的心态很平衡，但其实我走了很远。当然，有的同学会说，你进了北大就已经很成功了。确实，北大增加了我很多成功 的因素。比如，因为北大读书气氛很浓厚，所以我读了很多的书，思维变得很敏锐。 \n\n\n  北大确实有人文的环境，蔡元培的铜像就树立在未名湖边上，但是每年进北大的有好几千人，出北大的也有几千人，能够成功的到底有多少呢？事实上，北大学生成功的比率并不比任何一个大学生成功比例高。 \n\n\n  所有的成功意味着你大学毕业后要进一步付出努力，如果大学就意味成功的话，那么也就没有马云了。我跟马云有很多相同的地方，他高考考了3年，我也考了3 年，他考的是英语专业，我也考的是英语专业，第三年我去了北大，他去了杭州师范学院。我相信很多同学都没听说过这个学院，那我觉得我这辈子应该比他更加成 功吧，但是非常不幸的是，从今天来看，阿里巴巴上市的市值就是新东方的3倍，而我除了做成一个新东方便什么都没了。不仅如此，他还有淘宝网、支付宝…… \n\n\n  所以，你未来的成功和你上什么大学没有什么联系，只不过以后出国就业更加的容易一点。一辈子能不能走出精彩，大学为你奠定了基础，但不能决定你的一生。到 大学毕业人生也只过了四分之一，接下来的时间我们该怎么过呢？首先是一定要坚持走下去，因为你不活了就什么都没有了。不管你相信不相信来世，我始终相信今 生今世就是我们最好的天堂。所以我最讨厌自杀或者以自杀为威胁，我觉得这是对生命不尊重。有种理念，叫做“好死不如赖活着”。因为从我40多年的人生经验 来体会，你在那坐久了，说不定天上真的会掉下馅饼来，当然也可能掉下块陨石。但不管怎样，不要自我了断，生命中会有很多奇迹发生。假如杨振宁教授不活到 82岁，他怎么知道还能结第二次婚呢？\n\n\n  但是同学们，人生总是要有份期待，哪怕是没有希望的期待。同学们可以想一下我们历史上有很多人物，比如说姜太公在河边钓鱼，到了80岁那一年，周文王在他 边上走过，发现这个老头用直的鱼竿钓鱼，跟他一聊便发现这个老头很有智慧，所以把他带回去，两人一起打下了周朝的天下。齐白石同志在50岁的时候还在做木 工，根本不是个伟大的画家，他的所有伟大的作品都是在80岁到90岁的时候完成的。所以生命总有这样的现象，有的人在年轻的时候有作为，有的人中年时候有 作为，有的人老年时候有作为。花儿总是在不同的季节开放，如果所有的鲜花都在春天开放完毕了，到了夏天、秋天、冬天没有任何的花儿开放你还会觉得这个自然 界是如此的美丽动人吗？ \n\n\n  所以大家想一想，如果人生所有的精彩都在大学里过完了，后面永远都是平淡，你觉得这人生会完美吗？换句话说，你大学里过的不那么精彩，毕业后却变得越来越 精彩是不是更加好呢？事实证明，我们很多同学在大学里的成绩总是名列前茅，可是大学毕业后却怎么也做不出什么事情来了。因为在社会上，并不是成绩在起作 用。成绩只能证明你智商比别人高，但并不能决定你一辈子就一定有出息。 \n\n\n  成功并不仅仅是你的成绩所决定的，最重要的是与社会打交道的能力，为人处世的能力。在各种混乱的人际关系中，寻找机会的能力，以及你最后领导一帮人跟你 一起创事业的能力。而所有的这一切都不是由你的成绩决定的。当然我并不是说，在大学不要好好学，拿到大学毕业证书这是必然的，因为在未来我们会发现这样一 个现象，假如，连大学本科文凭都拿不到的话，你的生命将充满艰难。\n\n\n   现在读过大学的人很多，有人说现在上大学没什么意思，因为找不到工作。确实到现在为止，今年应届毕业生找到工作的比例只有40%左右，但我相信这只是一 个临时现象，因为中国的产业结构还没有调整过来。从历史来看，中国大学生远远不多，因为中国从制造业正在转向咨询、信息、物流、服务等与世界沟通交流的行 业，也就意味着在座的所有大学生都具备这样的工作能力，必然能找到工作。 \n\n\n  一次有个大学生告诉我，俞老师我要创业，不上大学了。我说为什么，他说要向比尔·盖茨学习。我说世界上有几个比尔·盖茨，不就一个嘛，他说没关系，他可以 成为第二个。我说，那你为什么不上大学呢？他说，我考试不及格，上不下去了。这还是没法跟比尔·盖茨比的，人家是觉得自己的知识已经远远超过了老师，觉得 上大学已经是时间的浪费，要把自己的创造力及时的发挥出来，所以钻到自己的汽车库里研究微软去了。这是两种完全不一样的概念。 \n\n\n  当然我刚刚强调的是你学习成绩好并不一定今后就做的好。有一份统计数据，将大学成绩前10名和后10名的同学做过一个调研，以20年一个阶段来说，大学 最后10名的同学财富总量以及获得的社会地位，居然比前10名还要高。这就意味着，即便在大学里最落后的同学也不要放弃自己。比如，我在北大努力了5年， 在毕业的时候就是以全班倒数第五名毕业的，但现在我们班的第一名到第五名全在新东方。所以，我们永远都不要放弃自己。   \n  最精彩的人生是到老年的时候能够写出一部回忆录来，自己会因曾经经历过的生命而感动，会感动别人继续为生命的精彩而奋斗，这时候我才能说我的生命很充实。\n\n我10年前就碰到一个特别令人感动的故事：有一个大学生来找我，因为非常贫困，但想出国，想上新东方的班，但是他没钱所以跟我说他很想上新东方的课，但没 钱，能不能暑假在新东方兼职做教室管理员，并且安排他到班，查完学生的听课证扫完地后就在后面听课，我说当然可以。没想到这个学生又提了个要求，如果两个 月的兼职真的做的很好的话，能否给他500元工资让他买个录音机，我说没有问题。结果那孩子做了两个月，所有接触过他的人都说这孩子刻苦认真，所以到了两 个月后，我给他一千块钱的工资让他买录音机。他买好后，边听着录音机边流着泪。我知道他被自己的行为感动了，以后肯定有大出息，果不其然几年后他被耶鲁大 学以全额奖学金录取了，现在还在美国工作，年薪13万5千美元。所以说只有被自己感动的生命才会精彩。 \n\n\n   其实我也有一些让自己感动的故事，比如说我高考落榜。当时想着一定要考进大学，但没想过进北大，所以就拼命读书。有的时候你会发现你低着头一直往前走，目 标就会在你的后面。所以当我拿到北大录取通知书的时候，真的是仰天大笑然后嚎啕大哭，跟范进中举一模一样。但如果当时没有坚持的话，也许我现在仍然只是一 个农民的儿子。比如，当时我们村有个人跟我一样考了两年，他总分还比我高三分，当时我跟他说一起考第三年吧，但他的母亲说别考了，找个女人结婚算了，但当 时我跟我妈说你让我再考一年，结果第三年我真的考上了。所以我得出两个结论，1、人必须往前跑，不一定要跑的快，但是要跑的久；2、不能停下来，你不能三 天打渔两天晒网，要持之以恒。 \n\n\n  我走到今天没有一天懒惰过，我现在每天依然要工作近16个小时，从高考那天开始每天如此。但我发现，我还是比不过有些同事。从小学到高中，我学习也挺认真 的，成绩总是在前10到20名之间，而在大学我学习更加认真，但最后却以全班倒数第五名毕业。龟兔赛跑的故事我们从小学就知道了，而生活中也经常体现出 来。因为跑得快的人往往会停下来，而跑得慢的不能因为慢就不跑。只要跑，早晚会达到你所向往的终点。所以我们不要去计较大学时候谁的成绩高低，只要不停的 去追求就可以了。 \n\n\n  一个聪明的人一辈子所创造的成就不一定比一个笨的人所创造的多，因为笨的人每天都在创造，而聪明的人可能创造一段时间会停下，即便是爱迪生这种超级天才， 小时候也被认为是个白痴。爱因斯坦九岁才会说话，还好他有个好妈妈一直认为他是个天才，才使他成为一个伟大的科学家。所以当我的儿子到4岁时还不会说话， 我老婆着急地带他到处求医时，我说，别看，4岁不会说话很正常的。我老婆说，为什么正常，我说，不会说话是语言功能发育不完全，不代表头脑就不发达。所以 永远不要用你的现状去判断你的未来，只要你坚持就一定能获得你所意想不到的东西。 \n\n\n  后来我班级里很多同学都联系出国，我看了羡慕，想要追赶他们的步伐，所以也开始联系出国。整整4年，联系了无数的美国大学和专业，没有一个美国大学给我奖 学金。尽管拿到了几张录取通知书，但去美国大使馆签证，每次都拒签。当然，现在我的签证除了伊拉克的没有，其他国家几乎都有了。现在美国给我的签证是10 年多次往返商务签证。因为新东方是在美国上市的，他必须允许我任何一天随时随地都能进入美国。所以当我儿时的朋友到现在还在面向黄河，这辈子还没有走出过 我们镇的时候，我已经走遍了世界各地。大家想，在徐霞客、苏轼那个没有任何交通工具的时代，都能游遍山水，写下许多让我们感动和动人的文字，而在我们这个 科技兴盛的时代，如果没有在世界上留下一些的文字和足迹，你怎么对得起自己。 \n\n\n  有的同学说，俞老师因为你现在有钱了所以可以这么做。坦率的说，以前我没钱我也会这样做。因为小时候我最崇拜的人物就是徐霞客，因为他是我的老乡，住在 我家隔壁。只不过他是400年前住在我家隔壁，要知道地方上的名人对地方上少年的影响是非常巨大的。有次，我坐在长江边上看日出日落，我就在想徐霞客怎么 能走那么远呢？所以也会向往这辈子我是否能跟他走的一样远。 \n\n\n  正是因为有这样一个榜样在，我才会发现高考一次、两次我都不绝望，因为我知道走出农村边界的惟一办法就是考上大学。我想把农村户口变成城市户口，因为当时 城市户口是可以到处走的。尽管我平时很平和，但心中总是有一种愿望，叫做穿越地平线走向远方的渴望，就是看到眼前的地平线我总是不满足的，我总是希望翻开 地平线看看另一边到底是什么样的。 \n\n\n  大家都知道，只要你不断的超越地平线一定会有很多的风景在你眼前展示出来。这跟你有没有钱没关系。而我曾怀揣100元人民币，走到了泰山，走到了黄山，走 到了九华山，走到了庐山。我一边走一边帮人家干活，走到九华山发现没钱了，就睡到一个农民家里。那个农民在江边给我弄了个床，还找我要钱，而我口袋里只有 5块钱。于是，我就说帮他一起插秧来抵消住宿费。他左看右看说，大学生怎么会插秧呢？结果插了一天我插了四分之三，而他只插了四分之一，把他感动的半死不 活。他说，你怎么会插的那么快呢？我说，我14岁那年就获得过我们县的插秧冠军。然后，他晚上杀了一只鸡要我一起喝酒。他越聊越觉得我不像大学生更像农 民。第二天我走的时候，他居然掏了10块钱给我说，我知道你口袋里没钱了，明天还要去庐山，这点钱就给你当路费。 \n\n\n  生命是有各种活法的，但是哪怕你坐到书斋中间，一辈子也要让自己的生命变的伟大。陈景润一辈子没出过书斋，不也是世界上最伟大的数学家？所以不管在什么状 态下也要像一首诗写的那样“相信未来，热爱生命”。所以只有当我们的生命有了期待以后，才会有进步。有的时候，我们选择前进，不是因为我们有多么坚强。有 这么一句话让我很感动，也变成了我的座右铭：“坚持下去不是因为我很坚强，而是因为我别无选择。”新东方有一个运动，叫做徒步50公里。任何一个新东方新 入职的老师和员工都必须徒步50公里，而未来的每一年也都要徒步50公里。很多人从来没走过那么远的路，一般走到10公里就走不动了，尤其是要爬山涉水地 走。每次我都会带着新东方员工走，走到一半的时候会有人想退缩，我说不行，你可以不走，但是把辞职报告先递上来。当走到25公里的时候你只有3个选择，第 一，继续往前走；第二，往后退；但当你走到一半的时候，你往后退也是25公里，还不如坚持往前走呢；第三，站在原地不动。而在人生旅途中停止不前还有什么 希望呢？ \n\n\n  我们人生有很多迷茫和痛苦，而只要你坚持往前走，痛苦往往会解决掉。在走的过程中，我也痛苦得流过泪，也曾经痛苦得嚎啕大哭过，但我知道真的坚持下去不是 因为你坚强而是因为你别无选择。走到最后你会发现总会有成果。我没想到新东方能从培训13个学生，现在变成培训175万学生、其实所有这一切你都不一定要 去想，只要坚持往前走就行了。 \n\n\n  我们生命中总要去追寻一种经历，有的时候我们觉得人连条鱼都不如，因为我在加拿大的时候，我看过加拿大三文鱼回流，每次它回流产卵的时候，我总会发现生命 及其壮观，鱼卵产在沙子里会被其他动物吃掉很多。第二年春天的时候剩下的鱼卵会变成小鱼，小鱼会顺流而下，流到湖里，而在湖里又会被其他鱼类吃掉一些。一 年后，长大的鱼会顺着大河奔入海洋，然后绕太平洋一周，每四年一个循环。如果三文鱼就在海洋中待着不回到湖里产卵，它就不会死，但它是受到内心的召唤集中 在河口开始往前游，一旦游进河的时候就再也不吃任何东西拼命地往前游，然后游到目的地开始配对产卵，产好后就双双死亡。你会看到成千上万的红色死鱼漂在河 上，而老鹰和黑熊就在边上等着。 \n\n\n  我看了后特别感动，一条小小的三文鱼也知道，生的使命是不能放弃。那我们人生的使命呢，比如父母为我们献出了青春财富，把你养育成人。而我们未来变成父母 后也是一样。我们孩子的成长就是你的使命，而我们其他的使命感，如何让自己活得更加幸福，如何帮助别人，让这个社会变得更加有意义。为什么宗教人士会活得 相对简单，因为他们灌输了一种使命感。而连一条鱼都经历了小溪流、湖泊、大海，他尝到了淡水的清香和海水的苦涩，完成了生命的周期。如果我们这一辈子都没 有苦涩，没有幸福和甜美，那生命是很遗憾的。 \n\n\n  而你现在的状况并不决定于你的未来，我在北大的时候受到的打击比较多，首先是身份上的悬殊，确实我是穿着大补丁走进校园的，我们体育老师上课从来不叫我的 名字的，都是叫那个大补丁来做个动作。因为我在农村锻炼过，跳跃性动作做得蛮好看，所以我常常被叫出来做演示。 \n\n\n  开学第一天晚上，全班开班会，我起来讲了一句话。现在新东方的王强老师是我们班级的班长，站起来跟我说你能不能不讲日语。因为我一直在农村上学，所以我们 的语文老师从来没用普通话给我们上过课，我当时根本不知道普通话该怎么说。北大当时按照英语成绩分班，我当时因为高考英语考得蛮好所以被分到了A班，其实 我的听说水平并不好，所以到了A班一个月以后就被贬到了C班，而C班主要是针对那些语音语调及听力障碍的同学。等后来，我发现我和同学的智商真的有差距， 我的那些同学平时看他们学习也并不怎么认真怎么一到期末考试就能考出好成绩，我每天学习时间都要比他们多两三个小时，但每次期末考试都在全班倒数几名。这 让我的心情非常郁闷。 \n\n\n  当时，我们班50个同学，25个男生25个女生。一开始我听完这个数字就特别兴奋，但是没想到我们班的女生没一个正眼瞧我一眼的。到了2001年的时候我 们全班同学聚会，大家从世界各地赶回来。蓦然回首，大家突然发现班上那个挺没出息的，普通话也讲不好的，默默无闻的那个人怎么就成了全班最出色的了。这个 时候女同学们都热情的走上来握住我的手，后悔当初没下手。 \n\n\n  所以后来大学女生问我，俞老师我们现在找男朋友要什么标准，我说很简单，参考我的长相。当然如果长得像我，那是绝对不能放过的。凡是长得比我难看的也不要放过，因为这个世界上的规律就是，越难看的人内涵越丰富。 \n\n   大三的时候我最喜欢读的是《红楼梦》，而且刚好读到林黛玉咳嗽而死的那一章。结果发现自己也在吐血。到医院，医生一查说得了肺结核立刻关起来，一关就是 一年。我跟医生说像我这样的小伙子怎么会得肺结核呢？医生让我讲讲现状。我说，您看我学习特别刻苦，可成绩就是上不去，班里没有一个女孩子喜欢我。他说， 这种情况不得肺结核是完全不可能的。 \n\n\n  但这个病也给我带来了心态上的调整，因为我在大学一二年级，想要追赶我的同学就是我的精神支柱。但是到了三年级，病了一年后我完全改变了，我觉得活着就挺 好。然后我就给自己订了一个最低标准，至少保证大学毕业拿到毕业证书，最后国家给我分配一份工作就挺好。虽然我并没有放弃努力，结果反而获得一个更加开阔 的心胸。所以，到现在为止我学会了永远不要去比，因为总有比你更加优秀的，也总有比你更加落后的。 \n\n\n  这个世界上最正确的是跟自己比，想一想今天是不是比昨天进步了一点，想一想明年是不是比今年更加好一点。想一想，10年以后的你是不是比今年的你要更加出色。这样的心态一直保持到我大学毕业。 \n\n\n  大学毕业的时候，每个人都要上去讲一段话，比如后半辈子怎么过，我就上去讲了这么一段话：我说，同学们大家都很厉害，我追了大家5年没追上，但是请大家记 住了，以后扮演一个骆驼的同学肯定不会放弃自己，你们5年干成的事情我干10年，你们10年干成的事情我干20年，你们20年干成的事情我干40年，实在 不行我会保持心情愉快身体健康，到了80岁后把你们一个个送走了我再走。这是我个人保持到现在的人生态度，而我认为这种人生态度对我来说非常有效。 \n\n\n  有人问我，如果新东方没了怎么办？其实新东方早晚会没的，因为它已经是一个商业化运作的教育机构。大家想一想，前些天我们看到的一个消息，GE公司是美 国的标志，不照样濒临破产了吗？新东方可能以后也会这样，变成历史的痕迹。但是我想，即使新东方没有了我依然很成功，因为我的心态很成功。我追求生命的那 种向往和穿越地平线的渴望不会改变。我认为，新东方给我的是一种精神，一种力量，而不是新东方本身给我带来多少钱，当然如果新东方给我更多的钱，我也愿意 要，不要钱才是傻瓜呢。但更重要的是，有了钱能否做出一些更加有意义的事情来。比如说我现在一直都想做一个小小的私立大学，可能我无法做到像同济大学那么 大，但做到它的十分之一总是可以的吧？我在北京已经买了一块地，正在建大学校区，造完后它就跟新东方的上市公司脱钩了，变成一个非营利性的大学校园，那它 可能就变成了你做的另外一件事情。 \n\n\n  如何把自己的生命变的更充实是最重要的事情，所以说，哪天新东方不存在了是非常正常的。如果新东方没了，我照样会过来跟大家做讲座，而且心情会更加的开 朗。因为没有繁琐的事情了。我只要换个题目就行了今天叫“度过有意义的生命”，下次我改成“我是如何把新东方做没了的”。 \n\n\n  而在大学中，我们要做的几件事情就是：第一，把自己的知识结构打造完整；第二，就是要在大学里尽可能的多交朋友，因为你终身的朋友、合作者一定来自于你的 大学；第三，如果有可能的话，在大学里谈一场比较专一的恋爱，因为回顾我北大的生活一片灰色。我想为什么会是灰色呢？其实，不是因为成绩不好，而是因为在 大学5年我从来没有过花前月下的时光。所以一直成了我大学时代的遗憾。去年北京大学让我给所有北大新生做开学典礼的时候，我给他们强调一句，什么都不重 要，重要的是谈恋爱，而且谈恋爱也不用害怕失败，因为自杀也自杀不了，未名湖就那么浅，跳下去还能爬起来；第四，就是为未来的工作做好打算。未来的工作跟 你有多少朋友、跟你的专业知识学的多少是相关的。好好掌握你的专业，再差的专业也一定有人用，只要你学的好。 \n\n\n  我有一个朋友学的是越南语，越南语的确很少用，但所有的中央领导去越南都要找他，因为他是一流的越南语同声翻译专家。我还有一个大学同学研究蒋介石，研究 了10年，穷困潦倒。但后来他去美国做了一个报告，美国方面帮他召开了一个中国现代史人物研讨会，他在报告上讲了自己的研究经过，结果下面一个老教授热泪 盈眶。下来后一问，这个老教授也在美国研究了30年蒋介石，孤苦伶仃，就是找不到另一个研究蒋介石的，没想到有个“傻瓜”也在研究蒋介石。于是5万美元一 年，让我同学跟着他在美国读研究生，然后读了四年的博士生。读完以后老头退休，他就变成了那个学校的教授。我去看他的时候，他已经在纽约买了套小房子，买 了辆车娶了个老婆养了条狗。当时他跟我说，俞敏洪你看现在这一切都是蒋介石“给”我的。 \n\n\n  我想用这个例子来说明什么呢？就是研究什么不重要，重要的是只要你真的喜欢就去做，然后就会有人用你。反过来，如果你觉得这个专业你不太喜欢，但很适合我 找工作，这要不要学？当然要学。我就是这样一个状态，我从来没喜欢过英语，当初考英语只是因为数学不行。不喜欢英语是因为我的模仿能力不强。像我的班长王 强，能够把任何话都模仿的惟妙惟肖。我普通话练了一年，才练成大家能听懂的样子。我老婆是天津人，跟我一吵架就用天津话骂我，但是我到现在为止只会说一句 天津话。就是当她拿起棍子打我的时候，我向她大吼一声，“干嘛”（天津话）。 \n\n\n  但是后来我发现英语成了我生命中的工具，因为英语，我在北大当了老师。其实当初留北大并不是成绩好，而是当时正好四六级考试，北大各个系的同学都要学两 年英语，结果北大急缺老师。而一些优秀的毕业生都去了外交部、经贸部，工资又高。后来我们系主任急了说，最后5名给我留下来。留下来的5个人现在都变成博 士生导师了，可见现在北大教育质量如何。当然这是句玩笑话，他们后来也经过自己的努力，经历了很多次考试成了很优秀的教师。 \n\n\n  在登山的时候，你会在乎登山杖你喜欢不喜欢吗？不会，你只会在乎能否帮你登上山顶。那么英语就是我的登山杖，尽管我不是特别的喜欢，但我知道我要想攀上更 高的人生的山峰就必须需要这个登山杖。我本来想把自己变成中国英语专家前100位的，后来发现一点戏都没有，因为中国留学生归来的越来越多了，有的在国外 待了10年、20年，回来了怎么看英语水平都比我高。那我只能缩小范围，想变成英语语法专家。后来发现背单词不用动脑筋，所以就开始拼命地背单词，结果变 成了中国还算不错的词汇专家。 \n\n\n  除了学专业外，同学们要在大学里多读书。新东方人读书都非常多。读书多，就意味着眼界更加的开阔，更加会思考问题，更具有创新精神。新东方流传一句话叫做 “底蕴的厚度决定事业的高度”。底蕴的厚度主要来自于两方面，第一多读书，读了大量的书你的知识结构自然就会完整，就会产生智慧；第二就是多人生经历。把 人生经历的智慧和读书的智慧结合起来就会变成真正的大智慧，就会变成你未来创造事业的无穷无尽的源泉和工具。 \n\n\n  比如，新东方招聘重要岗位的人才都是我面试。我只有几个问题，第一你大学读了多少本书，如果你说只读了几十本书，那肯定我不会要你。我心中的最低标准是 200本书，而我在大学里读了800本书。新东方还有更红火的王强老师，在大学里读了1200本书，平均每天一本。有的人会问我，读过了忘了跟没读过有什 么区别呢？其实完全不一样。就像你谈恋爱，一个谈过恋爱后又变成光棍汉的人和一个光棍汉相比是有自信的。因为当他看到别人在谈恋爱的时候，他会在旁边“嘿 嘿，想当初老子也是谈过恋爱的嘛”。实在不行来不及读，你可以到书店看着那些书，记着那些名字用手摸一下，这样也能增加一点人文气质。 \n\n\n  我有一个理念，人活着要过一种诗意的生活，我们有多少时候是停下来看看月亮的，在假期去内蒙看一下漫天的繁星的，有多少同学看着朝霞和晚霞时心中感受过生 命的涌动的。当然也要身体力行。大学时候，有一个非常著名的诗人叫海子，写了著名的诗句“面朝大海，春暖花开”，但非常可惜的是他没能抵抗现实社会的压 力，卧轨自杀了。所以我们说一个人不能只在语言上表达诗意，还要在现实中去表达诗意。所以你必须克服现实中的障碍和挫折。有首诗叫“大漠孤烟直，长河落日 圆”。我对“长河落日圆”有非常深刻的感觉，但对“大漠孤烟直”却没有什么概念。所以，进入北大校门之后第一件事情就是走向沙漠，走向戈壁滩，走向大草 原。而到今天为止，这些地方成了我的精神家园。如果生命中一有过不去的事情，我就去蒙古草原上跟牧民一起骑马。牧民曾经说过，在汉人当中从来没看到像你那 样不要命的。 \n\n\n  回过来讲诗意的生活，在大学里打游戏上MSN不叫诗意的生活，而在一张床上拿着书一边看书然后慢慢地睡着那就是一种诗意。要关注时事政治，要把握一些世界 大事。这种能力将在你日后创业的过程中起到很大的作用。另外就是要尽可能地多交朋友，交朋友首先你要做个好人，你要做一个让人放心的人。在中国企业界就是 这样的状态，如果你是个好心的人，在困难的时候一定会有人帮助。比如，蒙牛的牛根生大家都听说过，他为人处世很实在。所以蒙牛出事后，他需要资金，只需要 打个电话我们就会把钱汇过去。而为什么连合同都不签我们就给他，道理很简单，信任。 \n\n\n  我也碰到过这样的情况，03年的时候遇到SARS，我们马上给学生退学费，新东方的流动资金一下子退光了。而当时我算下来，账上还缺2000万。于是我分 别给两个朋友打了电话，一人一千万当天晚上就搞定了。所以，你变成一个让别人相信的人，比做一个让别人防着你的人，得到的好处要多得多。而建立这种信任， 要做到以下几个要素：要以别人为中心不要以自己为中心；要有服务精神。 \n\n\n  当时我那些大学同学觉得我没出息，但为什么会回来跟我创业呢？这跟我大学里的行为有关。我大学里是个学习不好但挺喜欢帮别人的人。我们宿舍当时从来不排值 日生，因为地全是我扫的。还有就是宿舍的水也基本都是我打，而他们之所以后来放弃国外优秀的条件来和我一起创业还是跟我当时宿舍打水有关系。若干年后，我 去找那些大学同学回来，他们说连你那么没出息的人在中国都赚钱了那我们回来还了得？第二个理由是，我们知道你是个特别好的人，你有饭吃不会给我们喝粥，你 有粥喝不会让我们饿死，所以就回来了。所以在大学毕业连一个朋友都没有的人，这辈子想成功几乎是不可能的。 \n\n\n  还有在大学里要交几个真正能帮助你的人，比如：心胸比你开阔，眼光比你敏锐。我在大学里交的就是这样的朋友，做人就要跟着牛人跑。比如，王强老师有天才的 一面，而这些是我学不到。他喜欢读书，他一进大学就会把生活费一分为二，一份用来买书，一份用来买饭票，饭票吃完了决不用买书的钱，他宁可偷别人的饭票， 我觉得这个习惯很好，我也一分为二，饭票吃完了我就偷他的。每到周末我们就去买书，我不知道买什么书，所以他买什么我跟着买什么，他被我弄烦了说你能不能 不跟着我，我说你是我的班长有责任帮助落后同学。其实我知道他想把我赶走，因为当时他是我们班女生追求的对象，如果我不跟着他他就会带女生出去买书，我当 时就看穿了他这个阴谋。到现在为止我的读书老师就是王强，他的藏书接近6万本，他每当看到有好的便宜的书就会帮我买，贵的会发个消息让我自己买。\n\n\n  到现在为止我都要不断的读书。因为每当聚会，他们谈起好书的时候，一旦我没读过就会被他们说“你大学时候不用功，怎么现在还是这样。”所以，我们的读书氛 围之所以非常的浓厚，最重要的原因就是王强，而你非常需要这样的朋友。还有就是徐小平老师。大学里我觉得这个老师很好，很想认识。一个礼拜后我买了支小钢 笔送给他，敲开他家的门，他问我，你是谁。我说，我是你的学生，听了你的课后很感动，所以想跟你交个朋友，这是我带给你的小礼物。徐小平一看我手中拿着礼 物就让我进去了，进了他家的门发现有一大群年轻老师在那。原来他有个习惯，一到周五晚上都会招一批老师来他家聊天。我当然很想听，问我能不能留下来听，他 说不行啊，我们聊的都是些男男女女的问题，像你这样的纯情少年会被污染的。幸亏我反应快说，徐老师我在这方面刚好需要启蒙教育。机会总是自己发现的。我发 现没有人给他们烧水，于是，我就帮他们烧水煮方便面。连续去了4个礼拜，到了第5个礼拜我不去了。为什么不去，不是因为我烦了，而是我觉得一个人在该显示 重要性的时候一定要显示出来。果然徐小平一个电话过来说，你这个兔崽子怎么还不过来。我知道，不是我离不开他们而是他们离不开我了。从此，在一年的时间 里，我不停听他们聊天，等到我办新东方的时候，我去的第一家就是徐小平家。我跟他说新东方不缺英语老师，但缺有思想的人物，所以希望你回去管理新东方的思 想。所以在大学里要做的另外一件事情就是一定要交朋友，让自己变成一个别人信赖的人。 \n\n\n  而如果能谈一场恋爱还是很不错的。但谈恋爱有一个非常重要的前提条件就是要一心一意地爱。所谓一心一意的爱不是说，大学里只能谈一次恋爱，而是说一次只能谈一个。要爱到一个什么程度呢？要有这样的一个感觉，“为什么我的眼睛充满泪水？是因为我爱你爱的深沉”。 \n\n\n  第二个要素就是当你真的爱上一个人后，要以恰当的方式告诉他你爱他而不能只放在心里。我在大学就吃亏在爱上不少女孩子，但只放在心里，怕被别人拒绝。但 其实人的追求最好还是表现出来，就算被一个女孩子拒绝了，她回家一定会在日记上写上，“今天又有一个男孩追我咯”。有一年去美国，跟一个以前班里很喜欢的 女孩一起吃饭，她和她老公跟我一起吃饭。吃饭的时候我跟她说，其实我在大学对你特别有好感。她当时一拍大腿说当时你为什么不告诉我呢？ \n\n\n  第三条就是谈的要大度，所谓的大度就是说当另一个人爱上其他人的时候一定要大度的对他说，你的幸福就是我的幸福，你的快乐就是我的快乐。我始终觉得人在世界上总是有缘分的，如果大学没有人爱你，在你以后的人生中总是会有人爱你，等你一起牵手走向今后的旅程。 \n\n\n  我是一个特别热爱生命的人我走路连蚂蚁都不敢踩，我想踩死那只公蚂蚁那只母蚂蚁怎么办。我吃鱼都不敢吃，我想吃了那条母鱼那公鱼该多痛苦啊，所以我一般不 吃鱼要吃吃两条。当然，大学的恋爱是一个过程，不管研究生还是本科生，毕业以后真结婚的比恋爱要少的多。比如我们班十几对谈恋爱，大学毕业后结婚了三对， 两年后离婚了两对。现在还剩下一对，这一对就是王强老师和他的夫人，我大学的同班同学。他们两人现在还过着幸福的生活。 \n\n\n  那么如果对大学的爱情有不满的也没有关系，看看我就行了。很多人都以为我不正常了，但是我还是照样地结婚了，照样找到心爱的人，照样生孩子，也有了比较 美好的家庭。总而言之，生活就是这样美好的往前走。有平凡，有激动，有慢慢长夜，也有美丽的日子，这就是我们的生活。 \n\n\n  还有就是工作问题。工作问题是一个比较简单的问题。我相信同济大学的同学在找工作的时候都不会有太大的困难，但是有同学问我要不要创业。人生一辈子不创一 次业一定是一件非常糟糕的事情。人一辈子总是要为自己干件事情，创业就是为自己干的事情。一份工作大家一起干，但是你并不一定大学毕业就要创业。为什么 呢？因为创业需要经验和许多前提条件。 \n\n\n  第一，你的专业知识能在你创业中的运用；第二，你有能和同学朋友相处并且有分配利益关系的能力；第三，你要有对付中国社会如此复杂局面的能力；第四，你要 有基本的商业操作原则或者商业运作知识；第五，自己要是个具有领导力的人；第六，你要有自己领域的运作知识和专业知识。 \n\n\n  比如，你想搞个培训学校，那你的运作知识从什么地方来呢？这个运作知识需要你通过观察别人怎么做得来的。如果当初我直接从北大出来就做新东方，那我是永 远做不成的。我做新东方有两个前提条件。第一个，我在北大做了六年老师，所以做老师做的不错。还有第二个前提条件，我做新东方以前，我在另外一家培训机构 干了近三年，我就在观察它是怎么做的。我碰到许多大学创业失败的人。我说你们怎么不创业了？他们说，同学之间只要一碰到利益关系，互相全是“狗屁”。是不 是这样？是的，但是你会处理了就不是“狗屁”了。我和新东方这帮朋友也有利益关系，但是我不就处理好了吗？所以说现在关键是考虑有没有这样的本领。要创业 但是我鼓励同学们先去某一个行业至少观察一到两年，最好是三到四年，慢慢积累自己的才能，自己也慢慢变得成熟，个性也慢慢变得稳定，最后再创业这样失败的 机会也少了很多。 \n\n\n  创业有两种状态，第一种就是从零做起，我自己就是从零做起，马云也是从零做起。第二种创业就像杨元庆，也算创业，杨元庆是接柳传志的班最后变成了联想老 总。美国著名的管理学家、企业家杰特威尔逊，他也是从一个普通工人做起，做了20年变成公司的老总；在公司老总的位置上干了20年把公司变成了全世界最大 的公司。这也是创业，不一定是自己干。 \n\n\n  有学生问，俞老师，我怎么把一个培训机构和你干得一样大？很简单先到新东方来打扫卫生，如果你把卫生打扫的非常干净，那么我把你提升为卫生部长，如果你 卫生部长干得好你就变成新东方后勤主任，等到你变成新东方后勤主任的时候，我就把你送到哈佛大学去学习了，学习完了回来我就把后勤行政全部交给你，你就变 成后勤行政总裁。第几位？第二位。我“一翘辫子”你就是总裁了对不对？所以我们的成熟是慢慢来的，就像一棵树长大也是慢慢长大，哪有一下子就能变成自己创 业成功的人？虽然这种人还是有的，但也是少数。我是32岁创业的，32岁才有了新东方。所以不要着急，人一辈子做多大的事都无所谓。 \n\n\n  还是我的老话：把生命活得精彩一点。我的比喻就是大树与小草的比喻，还有另外一个比喻：人的生活就像溪流一样，总有一个梦想——流进大海。有的人这一辈子 没有流向大海，这条河就是不完整的。长江流向大海，黄河流向大海，但长江、黄河以自己不同的方式流向大海。长江开山劈石穿过大山流向大海，黄河没有开山劈 石，结果绕过九曲十八弯。但是不管怎么样，生命再弯最后目标不变。我们惟一要记住的就是要像黄河、长江一样不断地向前流，但是不能变成黄河、长江里面的泥 沙，最后自己沉淀下去，把生命给沉淀没了。总而言之，生命的精彩只靠自己不靠别人。从来没有什么救世主，想要活得精彩、幸福，只能靠我们身边的每一个朋友 的共同努力！\n","tags":["Other"]},{"title":"ForkJoinSumCalculator","url":"/2022/03/15/ForkJoinSumCalculator/","content":"\n```java\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\nimport java.util.concurrent.RecursiveTask;\nimport java.util.function.Function;\nimport java.util.stream.LongStream;\n\npublic class ForkJoinSumCalculator extends RecursiveTask<Long> {\n    private final long[] numbers;\n    private final int start;\n    private final int end;\n\n    public static final long THRESHOLD = 10_000;\n\n    public ForkJoinSumCalculator(long[] numbers) {\n        this(numbers, 0, numbers.length);\n    }\n\n    private ForkJoinSumCalculator(long[] numbers, int start, int end) {\n        this.numbers = numbers;\n        this.start = start;\n        this.end = end;\n    }\n\n\n    @Override\n    protected Long compute() {\n        int length = end - start;\n        if (length <= THRESHOLD) {\n            return computeSequentially();\n        }\n        ForkJoinSumCalculator leftTask =\n                new ForkJoinSumCalculator(numbers, start, start + length / 2);\n        leftTask.fork();\n        ForkJoinSumCalculator rightTask =\n                new ForkJoinSumCalculator(numbers, start + length / 2, end);\n        Long rightResult = rightTask.compute();\n        Long leftResult = leftTask.join();\n        return leftResult + rightResult;\n    }\n\n    private Long computeSequentially() {\n        long sum = 0;\n        for (int i = start; i < end; i++) {\n            sum += numbers[i];\n        }\n        return sum;\n    }\n\n    public static long forJoinSum(long n) {\n        long[] numbers = LongStream.rangeClosed(1, n).toArray();\n        ForkJoinTask<Long> task = new ForkJoinSumCalculator(numbers);\n        return new ForkJoinPool().invoke(task);\n    }\n\n    public static long parallel(long n) {\n        return LongStream.rangeClosed(1, n).parallel().reduce(0, Long::sum);\n    }\n\n    public static void main(String[] args) {\n        measureSumPerf(ForkJoinSumCalculator::forJoinSum, 1000000L);\n        measureSumPerf(ForkJoinSumCalculator::parallel, 1000000L);\n\n    }\n\n    public static long measureSumPerf(Function<Long, Long> adder, Long n) {\n        long max = Long.MAX_VALUE;\n        for (int i = 0; i < 10; i++) {\n            long start = System.nanoTime();\n            Long result = adder.apply(n);\n            long time = (System.nanoTime() - start) / 1_000_000;\n            if (time < max) {\n                max = time;\n            }\n        }\n        System.out.println(max);\n        return max;\n    }\n}\n\n```\n\n","tags":["Java"]},{"title":"Observer","url":"/2022/03/11/Observer/","content":"\n\n\n## 观察者模式结构\n\n观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub），它是一种通知机制。\n\n1. **发布者** （Publisher） 向对应的订阅者发送事件，发布者内部有一个订阅者列表的数据结构，支持添加和移除订阅者。\n2. **订阅者** （Subscriber） 声明了通知接口。 在绝大多数情况下， 该接口仅包含一个方法，用来处理发布的事件。\n3. **具体订阅者** （Concrete Subscribers） 具体订阅者类实现了订阅者的接口，不同事件的处理逻辑。\n4. **事件**（Event）声明了事件接口。一个标识接口，标识是一个事件。\n5. **具体事件**（Concrete Event）具体事件，当事件通过发布者去发布的时候，发布者会遍历订阅列表执行对应的订阅者的方法。\n\n订阅者也叫观察者，被观察者就是发布的具体事件。在消息队列中，利用了发布-订阅模式工作，被观察者对应消息发送者（生产者），订阅者对应的是消费者。消息队列中内部有发布者的功能，订阅者将自己注册到里面，可以接收对应的系统发送的消息。 [参考代码](https://github.com/kangpanwork/Observer)\n\n","tags":["Design"]},{"title":"MySql-Transaction-Isolation-Level","url":"/2022/03/10/MySql-Transaction-Isolation-Level/","content":"\n\n# 事务的4大特性ACID\n原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。\n一致性（Consistent）：一方面，在事务开始之前和事务结束以后，数据库的完整性没有被破坏；另一方面，写入的数据必须完全符合所有的预设规则。\n隔离性（Isolation）：不同的会话或线程，操作数据库的时候可能产生多个事务。如果同时操作一张表或同一行数据，必然产生并发或干扰操作。隔离性要求事务间对表或数据操作是透明的，互相不存在干扰的，通过这种方式保证一致性。\n持久性（Durable）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n#  MySQL 事务的隔离级别\n\n\n\n## 准备环境\n\n```\n docker pull mysql\n docker run --name=mysql -it -p3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql\n docker ps -a\n docker exec -it 15084 bash\n mysql -u root -p\n mysql> create database kangpan\n mysql> use kangpan\n\n```\n\n\n\n## 准备数据\n\n```\nmysql> create table user(\n    -> id int(10) auto_increment,\n    -> name varchar(30) default null,\n    -> age tinyint(4) default null,\n    -> primary key (id)\n    -> )engine=innodb charset=utf8mb4;\n\n insert into user(id, name, age) values (1,'kangpan',31);\n\nmysql> select * from user;\n+----+---------+------+\n| id | name    | age  |\n+----+---------+------+\n|  1 | kangpan |   31 |\n+----+---------+------+\n1 row in set (0.00 sec)\n```\n\n## 事务并发可能出现的情况\n\n#### 脏读（Dirty Read）\n\n一个事务读到了另一个未提交事务修改过的数据\n\n\n\n#### 幻读（Phantom）\n\n一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）\n\n\n\n#### 不可重复读（Non-Repeatable Read）\n\n一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现）\n\n\n\n#### 幻读（Phantom）\n\n一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）\n\n\n\n## 事务的隔离级别\n\nMySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。\n\nMySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。\n\n隔离级别比较：可串行化>可重复读>读已提交>读未提交\n\n隔离级别对性能的影响比较：可串行化>可重复读>读已提交>读未提交\n\n由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。\n\n#### 读未提交（READ UNCOMMITTED）\n\n在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。\n\n可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。\n\n#### 读已提交（READ COMMITTED）\n\n在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。\n\n读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。\n\n#### 可重复读（REPEATABLE READ）\n\n在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。\n\n提问：为什么上了写锁（写操作），别的事务还可以读操作？\n\n因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。\n\n#### 可串行化（SERIALIZABLE）\n\n各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。\n\n\n\n## 隔离级别的实现原理\n\n使用MySQL的默认隔离级别（可重复读）来进行说明。\n\n每条记录在更新的时候都会同时记录一条回滚操作（回滚操作日志undo log）。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。即通过回滚（rollback操作），可以回到前一个状态的值。\n\n假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。\n\n- read-view A : 回滚段 将 2 改成 1\n- read-view B : 回滚段 将 3 改成 2\n\n- read-view C : 当前值 4 \n\nread-view A -> read-view B -> read-view C\n\n当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。\n\n同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。\n\n提问：回滚操作日志（undo log）什么时候删除？\n\nMySQL会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。\n\n提问：什么时候不需要了？\n\n当系统里么有比这个回滚日志更早的read-view的时候。\n\n我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行**回滚**，在 MySQL 中，恢复机制是通过 **回滚日志（undo log）** 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 **回滚日志** 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。\n\n另外，MVCC 的实现依赖于：**隐藏字段、Read View、undo log**。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改\n\n## 查看当前会话隔离级别\n\n#### 方式1\n\n```\n命令：SHOW VARIABLES LIKE 'transaction_isolation';\n\nmysql> show variables like 'transaction_isolation';\n+-----------------------+--------------+\n| Variable_name  | Value |\n+-----------------------+--------------+\n| transaction_isolation | SERIALIZABLE |\n+-----------------------+--------------+\n```\n\n#### 方式2\n\n```\n命令：SELECT @@transaction_isolation;\n\nmysql> select @@transaction_isolation;\n+-------------------------+\n| @@transaction_isolation |\n+-------------------------+\n| SERIALIZABLE            |\n+-------------------------+\n\nmysql> select @@global.transaction_isolation;\n+--------------------------------+\n| @@global.transaction_isolation |\n+--------------------------------+\n| READ-UNCOMMITTED               |\n+--------------------------------+\n1 row in set (0.01 sec)\n```\n\n## 设置隔离级别\n\n#### 方式1：通过set命令\n\n```\nSET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;\n其中level有4种值：\nlevel: {\n     REPEATABLE READ\n   | READ COMMITTED\n   | READ UNCOMMITTED\n   | SERIALIZABLE\n}\n```\n\n##### 关键词：GLOBAL\n\n```\nSET GLOBAL TRANSACTION ISOLATION LEVEL level;\neg: set global transaction isolation level read uncommitted;\n* 只对执行完该语句之后产生的会话起作用\n* 当前已经存在的会话无效\n```\n\n##### 关键词：SESSION\n\n```\nSET SESSION TRANSACTION ISOLATION LEVEL level;\n* 对当前会话的所有后续的事务有效\n* 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务\n* 如果在事务之间执行，则对后续的事务有效。\n```\n\n##### 无关键词\n\n```\nSET TRANSACTION ISOLATION LEVEL level;\n* 只对当前会话中下一个即将开启的事务有效\n* 下一个事务执行完后，后续事务将恢复到之前的隔离级别\n* 该语句不能在已经开启的事务中间执行，会报错的\n```\n\n#### 方式2：通过服务启动项命令\n\n> 可以修改启动参数transaction-isolation的值\n>\n> 比方说我们在启动服务器时指定了--transaction-isolation=READ UNCOMMITTED，那么事务的默认隔离级别就从原来的REPEATABLE READ变成了READ UNCOMMITTED。\n\n\n\n## 关于事务日志\n\n关于事务日志的说明中，我们可以看得出来，只要修改的数据已经写入到日志并且持久化了，数据本身还没有写入磁盘时，即使断电了，系统在重启的时候依然会将数据恢复。那么我们再来看看官网给出的innodb_flush_log_at_trx_commit 参数的介绍\n- 为0时，如果MySQL挂了或宕机可能会有1秒数据的丢失。\n- 为1时， 只要事务提交成功，redo log记录就一定在硬盘里，不会有任何数据丢失。如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。\n- 为2时， 只要事务提交成功，redo log buffer中的内容只写入文件系统缓存（page cache）。如果仅仅只是MySQL挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。\n\n该属性主要是为数据库的ACID原则进行服务的，并且默认为1，但是实际情况下设置为2会提高很多的事务性能，设置1的时候，innodb的缓存会在事务提交或者每秒钟时都会进行磁盘的刷新操作，2的时候，innodb缓存会在提交事务时写入到事务日志但不会刷新磁盘，然后在每秒钟时进行磁盘刷新操作，2要比1提高很多性能，事务没有commit时，断电了，此时肯定数据是没有更新成功的，因为都还没有来得及写入事务日志，事务提交后，在写入事务日志的时候，发生断电，此时无论是参数的值是1还是2，都应该恢复不了数据了，每秒钟刷新磁盘时，发生断电，此时既然事务日志已经持久化了，那么重启后，数据是会自动恢复的。\n\n#### 刷盘时机\n\nInnoDB 存储引擎为 redo log 的刷盘策略提供了 innodb_flush_log_at_trx_commit 参数，它支持三种策略：\n\n- **0** ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作，后台线程进行刷盘\n- **1** ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）\n- **2** ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache\n\ninnodb_flush_log_at_trx_commit 参数默认为 1 ，也就是说当事务提交时会调用 fsync 对 redo log 进行刷盘\n\n另外，InnoDB 存储引擎有一个后台线程，每隔1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。也就是说，一个没有提交事务的 redo log 记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入redo log buffer 中，这些 redo log 记录会被后台线程刷盘。除了后台线程每秒1次的轮询操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。\n\n\n#### 日志存储方式\n硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的redo日志文件大小都是一样的。\n比如可以配置为一组4个文件，每个文件的大小是 1GB，整个 redo log 日志文件组可以记录4G的内容。\n它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，在个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint\n- write pos 是当前记录的位置，一边写一边后移\n- checkpoint 是当前要擦除的位置，也是往后推移\n每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。如果 write pos 追上 checkpoint ，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。\n\n## 关于Autocommit\n\n当变量autocommit的值为ON时，代表自动提交开启，改为OFF则变为手动提交。在手动提交模式下，可以使用下面两种指令开启事务：\n\n\n```\nstart transaction;\nbegin;\n```\n\n结束事务的方式也有两种，事务确认提交\n```\ncommit;\nrollback;\n```\n\n```\nmysql> set @@autocommit=0;\n\nmysql> SHOW VARIABLES like '%autocommit%';\n+---------------+-------+\n| Variable_name | Value |\n+---------------+-------+\n| autocommit    | OFF   |\n+---------------+-------+\n1 row in set (0.00 sec)\n```\n\n## 悲观锁与乐观锁\n\n- **悲观锁**：悲观锁指对数据被意外修改持保守态度，依赖数据库原生支持的锁机制来保证当前事务处理的安全性，防止其他并发事务对目标数据的破坏或破坏其他并发事务数据，将在事务开始执行前或执行中申请锁定，执行完后再释放锁定。这对于长事务来讲，可能会严重影响系统的并发处理能力\n\n  ```\n  LOCK TABLES a WRITE;\n  INSERT INTO a VALUES (1,23),(2,34),(4,33);\n  INSERT INTO a VALUES (8,26),(6,29);\n  UNLOCK TABLES;\n  ```\n\n  锁定表可以加速用多个语句执行的INSERT操作，因为索引缓存区仅在所有INSERT语句完成后刷新到磁盘上一次。一般有多少INSERT语句即有多少索引缓存区刷新，如果能用一个语句插入所有的行，就不需要锁定；对于事务表，应使用BEGIN和COMMIT代替LOCK TABLES来加快插入\n\n- **乐观锁**：乐观锁相对悲观锁而言，先假想数据不会被并发操作修改，没有数据冲突，只在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则宣告失败，否则更新数据。这就要求避免使用长事务和锁机制，以免导致系统并发处理能力降低，保障系统生产效率。下面将说明使用乐观锁时的大致业务处理流程\n\n  ```\n  首 步：执行一次查询 select some_column as old_value from some_table where id = id_value (假设该值在当前业务处理过程中不会被其他并发事务修改)\n  ...\n  第n步：old_value参与中间业务处理，比如old_value被自己修改 new_value = f(old_value)。这期间可能耗时很长，但不会为持有 some_column 而申请所在的行或表锁定，因此其他并发事务可以获得该锁\n  ...\n  尾 步：执行条件更新 update some_table set some_column = new_value where id = id_value and some_column = old_value (条件更新中检查old_value是否被修改)\n  ```\n\n## 三大日志\nMySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。MySQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。\n","tags":["MySql"]},{"title":"MyBatis-Plugin-Development","url":"/2022/03/10/MyBatis-Plugin-Development/","content":"\n\n\n## MyBatis插件开发流程\n\n- 类实现Interceptor接口；\n\n- 类上添加注解\n\n  ```\n  @Intercepts({@Signature(type, method, args)})\n  ```\n\n  - **type**：需要拦截的对象，只可取四大对象之一Executor.class、StatementHandler.class、ParameterHandler.class、ResultSetHandler.class。\n  - **method**：拦截的对象方法。\n  - **args**：拦截的对象方法参数。\n\n- 实现拦截的方法Object intercept(Invocation invocation)。\n\n##  Interceptor接口\n\n```\npublic interface Interceptor {\n\n    /**\n     * 此方法将直接覆盖被拦截对象的原有方法\n     *\n     * @param invocation 通过该对象可以反射调度拦截对象的方法\n     * @return\n     * @throws Throwable\n     */\n    Object intercept(Invocation invocation) throws Throwable;\n\n    /**\n     * 为被拦截对象生成一个代理对象，并返回它\n     *\n     * @param target 被拦截的对象\n     * @return\n     */\n    Object plugin(Object target);\n\n    /**\n     * 设置插件配置的参数\n     *\n     * @param properties 插件配置的参数\n     */\n    void setProperties(Properties properties);\n\n}\n```\n\n## 步骤\n\n### 确定拦截的方法签名\n\n需要在实现Interceptor接口的类上加入@Intercepts({@Signature(type, method, args)})注解才能够运行插件。\n\n#### type－拦截的对象\n\n- Executor 执行的SQL 全过程，包括组装参数、组装结果返回和执行SQL的过程等都可以拦截。\n- StatementHandler 执行SQL的过程，拦截该对象可以重写执行SQL的过程。\n- ParameterHandler 执行SQL 的参数组装，拦截该对象可以重写组装参数的规则。\n- ResultSetHandler 执行结果的组装，拦截该对象可以重写组装结果的规则。\n\n对于分页插件，我们只需要拦截StatementHandler对象，重写SELECT类型的SQL语句，实现分页功能。\n\n\n\n#### method－拦截的方法\n\n我们已经能够确定拦截的对象是StatementHandler了，现在我们要确定拦截的是哪个方法，因为StatementHandler是通过prepare方法对SQL进行预编译的，所以我们需要对prepare方法进行拦截，在这个方法执行之前，完成SQL的重新编写，加入limit。\n\n**StatementHandler**\n\n```\npublic interface StatementHandler {\n\n  /**\n   * 预编译SQL\n   *\n   * @param connection\n   * @return\n   * @throws SQLException\n   */\n  Statement prepare(Connection connection)\n      throws SQLException;\n\n  /**\n   * 设置参数\n   *\n   * @param statement\n   * @throws SQLException\n   */\n  void parameterize(Statement statement)\n      throws SQLException;\n\n  /**\n   * 批处理\n   *\n   * @param statement\n   * @throws SQLException\n   */\n  void batch(Statement statement)\n      throws SQLException;\n\n  /**\n   * 执行更新操作\n   *\n   * @param statement\n   * @return 返回影响行数\n   * @throws SQLException\n   */\n  int update(Statement statement)\n      throws SQLException;\n\n  /**\n   * 执行查询操作，将结果交给ResultHandler进行结果的组装\n   *\n   * @param statement\n   * @param resultHandler\n   * @param <E>\n   * @return 返回查询的数据列表\n   * @throws SQLException\n   */\n  <E> List<E> query(Statement statement, ResultHandler resultHandler)\n      throws SQLException;\n\n  /**\n   * 得到绑定的sql\n   * \n   * @return\n   */\n  BoundSql getBoundSql();\n\n  /**\n   * 得到参数处理器\n   * \n   * @return\n   */\n  ParameterHandler getParameterHandler();\n\n}\n```\n\n#### args－拦截的参数\n\nargs是一个Class类型的数组，表示的是被拦截方法的参数列表。由于我们已经确定了拦截的是StatementHandler的prepare方法，而该方法只有一个参数Connection，所以我们只需要拦截这一个参数即可。\n\n### 实现拦截方法\n\n定义一个封装分页参数的类Page\n\n```\npublic class Page {\n\n    /**\n     * 当前页码\n     */\n    private Integer pageIndex;\n    /**\n     * 每页数据条数\n     */\n    private Integer pageSize;\n    /**\n     * 总数据数\n     */\n    private Integer total;\n    /**\n     * 总页数\n     */\n    private Integer totalPage;\n\n    public Page() {\n    }\n\n    public Page(Integer pageIndex, Integer pageSize) {\n        this.pageIndex = pageIndex;\n        this.pageSize = pageSize;\n    }\n\t// 省略get、set方法...\n}\n```\n\n实现插件分页的功能\n\n```\nimport org.apache.ibatis.executor.parameter.ParameterHandler;\nimport org.apache.ibatis.executor.statement.StatementHandler;\nimport org.apache.ibatis.mapping.BoundSql;\nimport org.apache.ibatis.mapping.MappedStatement;\nimport org.apache.ibatis.plugin.*;\nimport org.apache.ibatis.reflection.MetaObject;\nimport org.apache.ibatis.reflection.SystemMetaObject;\nimport org.apache.ibatis.scripting.defaults.DefaultParameterHandler;\nimport org.apache.ibatis.session.Configuration;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n\n@Intercepts({@Signature(\n        type = StatementHandler.class,\n        method = \"prepare\",\n        args = {Connection.class}\n)})\npublic class PagingPlugin implements Interceptor {\n\n    /**\n     * 默认页码\n     */\n    private Integer defaultPageIndex;\n    /**\n     * 默认每页数据条数\n     */\n    private Integer defaultPageSize;\n\n    public Object intercept(Invocation invocation) throws Throwable {\n        StatementHandler statementHandler = getUnProxyObject(invocation);\n        MetaObject metaObject = SystemMetaObject.forObject(statementHandler);\n        String sql = getSql(metaObject);\n        if (!checkSelect(sql)) {\n            // 不是select语句，进入责任链下一层\n            return invocation.proceed();\n        }\n\n        BoundSql boundSql = (BoundSql) metaObject.getValue(\"delegate.boundSql\");\n        Object parameterObject = boundSql.getParameterObject();\n        Page page = getPage(parameterObject);\n        if (page == null) {\n            // 没有传入page对象，不执行分页处理，进入责任链下一层\n            return invocation.proceed();\n        }\n\n        // 设置分页默认值\n        if (page.getPageIndex() == null) {\n            page.setPageIndex(this.defaultPageIndex);\n        }\n        if (page.getPageSize() == null) {\n            page.setPageSize(this.defaultPageSize);\n        }\n        // 设置分页总数，数据总数\n        setTotalToPage(page, invocation, metaObject, boundSql);\n        // 校验分页参数\n        checkPage(page);\n        return changeSql(invocation, metaObject, boundSql, page);\n    }\n\n    public Object plugin(Object target) {\n        // 生成代理对象\n        return Plugin.wrap(target, this);\n    }\n\n    public void setProperties(Properties properties) {\n        // 初始化配置的默认页码，无配置则默认1\n        this.defaultPageIndex = Integer.parseInt(properties.getProperty(\"default.pageIndex\", \"1\"));\n        // 初始化配置的默认数据条数，无配置则默认20\n        this.defaultPageSize = Integer.parseInt(properties.getProperty(\"default.pageSize\", \"20\"));\n    }\n\n    /**\n     * 从代理对象中分离出真实对象\n     *\n     * @param invocation\n     * @return\n     */\n    private StatementHandler getUnProxyObject(Invocation invocation) {\n        // 取出被拦截的对象\n        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();\n        MetaObject metaStmtHandler = SystemMetaObject.forObject(statementHandler);\n        Object object = null;\n        // 分离代理对象\n        while (metaStmtHandler.hasGetter(\"h\")) {\n            object = metaStmtHandler.getValue(\"h\");\n            metaStmtHandler = SystemMetaObject.forObject(object);\n        }\n\n        return object == null ? statementHandler : (StatementHandler) object;\n    }\n\n    /**\n     * 判断是否是select语句\n     *\n     * @param sql\n     * @return\n     */\n    private boolean checkSelect(String sql) {\n        // 去除sql的前后空格，并将sql转换成小写\n        sql = sql.trim().toLowerCase();\n        return sql.indexOf(\"select\") == 0;\n    }\n\n    /**\n     * 获取分页参数\n     *\n     * @param parameterObject\n     * @return\n     */\n    private Page getPage(Object parameterObject) {\n        if (parameterObject == null) {\n            return null;\n        }\n\n        if (parameterObject instanceof Map) {\n            // 如果传入的参数是map类型的，则遍历map取出Page对象\n            Map<String, Object> parameMap = (Map<String, Object>) parameterObject;\n            Set<String> keySet = parameMap.keySet();\n            for (String key : keySet) {\n                Object value = parameMap.get(key);\n                if (value instanceof Page) {\n                    // 返回Page对象\n                    return (Page) value;\n                }\n            }\n        } else if (parameterObject instanceof Page) {\n            // 如果传入的是Page类型，则直接返回该对象\n            return (Page) parameterObject;\n        }\n\n        // 初步判断并没有传入Page类型的参数，返回null\n        return null;\n    }\n\n    /**\n     * 获取数据总数\n     *\n     * @param invocation\n     * @param metaObject\n     * @param boundSql\n     * @return\n     */\n    private int getTotal(Invocation invocation, MetaObject metaObject, BoundSql boundSql) {\n        // 获取当前的mappedStatement对象\n        MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(\"delegate.mappedStatement\");\n        // 获取配置对象\n        Configuration configuration = mappedStatement.getConfiguration();\n        // 获取当前需要执行的sql\n        String sql = getSql(metaObject);\n        // 改写sql语句，实现返回数据总数 $_paging取名是为了防止数据库表重名\n        String countSql = \"select count(*) as total from (\" + sql + \") $_paging\";\n        // 获取拦截方法参数，拦截的是connection对象\n        Connection connection = (Connection) invocation.getArgs()[0];\n        PreparedStatement pstmt = null;\n        int total = 0;\n\n        try {\n            // 预编译查询数据总数的sql语句\n            pstmt = connection.prepareStatement(countSql);\n            // 构建boundSql对象\n            BoundSql countBoundSql = new BoundSql(configuration, countSql, boundSql.getParameterMappings(),\n                    boundSql.getParameterObject());\n            // 构建parameterHandler用于设置sql参数\n            ParameterHandler parameterHandler = new DefaultParameterHandler(mappedStatement, boundSql.getParameterObject(),\n                    countBoundSql);\n            // 设置sql参数\n            parameterHandler.setParameters(pstmt);\n            //执行查询\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                total = rs.getInt(\"total\");\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            if (pstmt != null) {\n                try {\n                    pstmt.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        // 返回总数据数\n        return total;\n    }\n\n    /**\n     * 设置总数据数、总页数\n     *\n     * @param page\n     * @param invocation\n     * @param metaObject\n     * @param boundSql\n     */\n    private void setTotalToPage(Page page, Invocation invocation, MetaObject metaObject, BoundSql boundSql) {\n        // 总数据数\n        int total = getTotal(invocation, metaObject, boundSql);\n        // 计算总页数\n        int totalPage = total / page.getPageSize();\n        if (total % page.getPageSize() != 0) {\n            totalPage = totalPage + 1;\n        }\n\n        page.setTotal(total);\n        page.setTotalPage(totalPage);\n    }\n\n    /**\n     * 校验分页参数\n     *\n     * @param page\n     */\n    private void checkPage(Page page) {\n        // 如果当前页码大于总页数，抛出异常\n        if (page.getPageIndex() > page.getTotalPage()) {\n            throw new RuntimeException(\"当前页码［\" + page.getPageIndex() + \"］大于总页数［\" + page.getTotalPage() + \"］\");\n        }\n        // 如果当前页码小于总页数，抛出异常\n        if (page.getPageIndex() < 1) {\n            throw new RuntimeException(\"当前页码［\" + page.getPageIndex() + \"］小于［1］\");\n        }\n    }\n\n    /**\n     * 修改当前查询的sql\n     *\n     * @param invocation\n     * @param metaObject\n     * @param boundSql\n     * @param page\n     * @return\n     */\n    private Object changeSql(Invocation invocation, MetaObject metaObject, BoundSql boundSql, Page page) throws Exception {\n        // 获取当前查询的sql\n        String sql = getSql(metaObject);\n        // 修改sql，$_paging_table_limit取名是为了防止数据库表重名\n        String newSql = \"select * from (\" + sql + \") $_paging_table_limit limit ?, ?\";\n        // 设置当前sql为修改后的sql\n        setSql(metaObject, newSql);\n\n        // 获取PreparedStatement对象\n        PreparedStatement pstmt = (PreparedStatement) invocation.proceed();\n        // 获取sql的总参数个数\n        int parameCount = pstmt.getParameterMetaData().getParameterCount();\n        // 设置分页参数\n        pstmt.setInt(parameCount - 1, (page.getPageIndex() - 1) * page.getPageSize());\n        pstmt.setInt(parameCount, page.getPageSize());\n\n        return pstmt;\n    }\n\n    /**\n     * 获取当前查询的sql\n     *\n     * @param metaObject\n     * @return\n     */\n    private String getSql(MetaObject metaObject) {\n        return (String) metaObject.getValue(\"delegate.boundSql.sql\");\n    }\n\n    /**\n     * 设置当前查询的sql\n     *\n     * @param metaObject\n     */\n    private void setSql(MetaObject metaObject, String sql) {\n        metaObject.setValue(\"delegate.boundSql.sql\", sql);\n    }\n}\n```\n\n### 配置分页插件\n\n在mybatis-config.xml配置文件中配置自定义的分页插件\n\n```\n<plugins>\n\t<plugin interceptor=\"PagingPlugin\">\n\t\t<property name=\"default.pageIndex\" value=\"1\"/>\n\t\t<property name=\"default.pageSize\" value=\"20\"/>\n\t</plugin>\n</plugins>\n```\n\n### 实现DAO\n\n```\npublic class Role {\n\n   private Long id;\n   private String roleName;\n   private String note;\n   // 省略get、set...\n}\n```\n\n定义Mapper接口，通过分页对象查询角色列表\n\n```\npublic interface RoleMapper {\n    List<Role> listRoleByPage(Page page);\n}\n```\n\n定义Mapper.xml编写查询的SQL语句\n\n```\n<mapper namespace=\"RoleMapper\">\n    <select id=\"listRoleByPage\" resultType=\"Role\">\n        SELECT id, role_name, note FROM role\n    </select>\n</mapper>\n```\n\n### 测试分页插件\n\n测试代码\n\n```\n@Test\npublic void test() {\n\tInputStream inputStream = null;\n\tSqlSessionFactory sqlSessionFactory;\n\tSqlSession sqlSession = null;\n\ttry {\n\t\tinputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\n\t\tsqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n\t\tsqlSession = sqlSessionFactory.openSession();\n\t\tRoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);\n\t\t// 分页参数，从第一页开始，每页显示5条数据\n\t\tPage page = new Page(1, 5);\n\t\tList<Role> roleList = roleMapper.listRoleByPage(page);\n\t\tSystem.out.println(\"===分页信息===\");\n\t\tSystem.out.println(\"当前页码：\" + page.getPageIndex());\n\t\tSystem.out.println(\"每页显示数据数：\" + page.getPageSize());\n\t\tSystem.out.println(\"总数据数：\" + page.getTotal());\n\t\tSystem.out.println(\"总页数：\" + page.getTotalPage());\n\t\tSystem.out.println(\"=============\");\n\t\tSystem.out.println(\"===数据列表===\");\n\t\tfor (Role role : roleList) {\n\t\t\tSystem.out.println(role);\n\t\t}\n\t} catch (IOException e) {\n\t\te.printStackTrace();\n\t} finally {\n\t\tif (sqlSession != null) {\n\t\t\tsqlSession.close();\n\t\t}\n\t\tif (inputStream != null) {\n\t\t\ttry {\n\t\t\t\tinputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n数据库role表中的全部数据信息\n\n| id   | role_name   | note       |\n| ---- | ----------- | ---------- |\n| 1    | SUPER_ADMIN | 超级管理员 |\n| 2    | admin       | 管理员     |\n| 3    | user        | 用户       |\n| 4    | user2       | 用户2      |\n| 8    | user3       | 用户3      |\n| 9    | test        | 测试       |\n| 10   | test2       | 测试2      |\n| 11   | test3       | 测试3      |\n| 12   | test4       | 测试4      |\n| 13   | test5       | 测试5      |\n\n代码执行结果\n\n```\n===分页信息===\n当前页码：1\n每页显示数据数：5\n总数据数：10\n总页数：2\n=============\n===数据列表===\nRole{id=1, roleName='SUPER_ADMIN', note=' 超级管理员'}\nRole{id=2, roleName='admin', note='管理员'}\nRole{id=3, roleName='user', note='用户'}\nRole{id=4, roleName='user2', note='用户2'}\nRole{id=8, roleName='user3', note='用户3'}\n```\n\n打印的SQL信息\n\n```\n==>  Preparing: select count(*) as total from (SELECT id, role_name, note FROM role) $_paging \n==> Parameters: \n<==    Columns: total\n<==        Row: 10\n<==      Total: 1\n==>  Preparing: select * from (SELECT id, role_name, note FROM role) $_paging_table_limit limit ?, ? \n==> Parameters: 0(Integer), 5(Integer)\n<==    Columns: id, role_name, note\n<==        Row: 1, SUPER_ADMIN,  超级管理员\n<==        Row: 2, admin, 管理员\n<==        Row: 3, user, 用户\n<==        Row: 4, user2, 用户2\n<==        Row: 8, user3, 用户3\n<==      Total: 5\n```","tags":["MyBatis"]},{"title":"Run-Time-Data-Areas","url":"/2022/03/09/Run-Time-Data-Areas/","content":"\n\n\n## The pc Register - 程序计数器\n\n线程私有内存，保存**当前线程所执行的字节码的行号指示器**，这里和计算机组成原理中的计数器不太一样，计组中的 PC 指的是**下一条要执行的指令**的地址。JVM 中常有多个线程执行，故每条线程都需要有一个独立的程序计数器。\n\n如果线程执行的是 Java 方法，哪儿计数器记录的就是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，这个计数器则为空。\n\nP.S. 这块内存无OutOfMemoryError\n\n## Java Virtual Machine Stacks - Java 虚拟机栈\n\n线程私有，虚拟机栈描述的是 Java 方法执行的内存模型，每个方法在执行时会创建一个栈帧，栈帧中保存有局部变量表、操作数栈、动态链接和方法出口等。粗略来讲 Java 内存区分为堆和栈，实际上『栈』指的往往是虚拟机栈中的局部变量表部分。\n\n局部变量表中存放了编译期可知的各种基本数据类型、对象引用类型和 returnAddress 类型。方法运行期间局部变量表大小不变。\n\n## Native Method Stacks - 本地方法栈\n\n和虚拟机栈类似，不过区别在于虚拟机栈为 Java 方法（字节码）服务，而本地方法栈为 Native 方法服务（类似 C 语言中的栈）。具体实现可将这两者合二为一。\n\n## Heap - 堆\n\n堆是被所有线程共享的一块内存区域。一般来说所有的对象实例和数组都要在堆上分配，但一些优化技术导致不一定所有对象实例都在堆上分配。\n\n## Method Area - 方法区\n\n各线程共享的一块内存区域，和操作系统中进程中的『文本段』有些类似，用于存储虚拟机加载的类信息、常量、静态常量和即时编译器编译后的代码数据等。\n\n## Run-Time Constant Pool - 运行时常量池\n\n这一部分是方法区的一部分，用于保存 Class 文件中编译期生成的字面值和符号引用。\n\n## 直接内存\n\n这一部分并不是虚拟机运行时的数据区域，用于 Native 函数分配堆外内存，提高性能用（不必在操作系统堆和 Java 堆复制数据）。","tags":["Java"]},{"title":"Install-WSL","url":"/2022/03/09/Install-WSL/","content":"\n\n\n为简单起见，通常建议使用 [`wsl --install`](https://docs.microsoft.com/zh-cn/windows/wsl/install) 安装适用于 Linux 的 Windows 子系统，但如果运行的是旧版 Windows，则可能不支持这种方式。 下面介绍了手动安装步骤。 如果在安装过程中遇到问题，请查看[疑难解答指南的安装部分](https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting#installation-issues)。\n\n## 步骤 1 - 启用适用于 Linux 的 Windows 子系统\n\n需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。\n\n以管理员身份打开 PowerShell（“开始”菜单 >“PowerShell”> 单击右键 >“以管理员身份运行”），然后输入以下命令：\n\nPowerShell复制\n\n```powershell\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n```\n\n建议现在转到步骤 #2，更新到 WSL 2，但如果只想安装 WSL 1，现在可以重新启动计算机，然后继续执行[步骤 6 - 安装所选的 Linux 发行版](https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-6---install-your-linux-distribution-of-choice)。 若要更新到 WSL 2，请等待重新启动计算机，然后继续执行下一步。\n\n## 步骤 2 - 检查运行 WSL 2 的要求\n\n若要更新到 WSL 2，需要运行 Windows 10。\n\n- 对于 x64 系统：**版本 1903** 或更高版本，采用**内部版本 18362** 或更高版本。\n- 对于 ARM64 系统：**版本 2004** 或更高版本，采用**内部版本 19041** 或更高版本。\n- 低于 18362 的版本不支持 WSL 2。 使用 [Windows Update 助手](https://www.microsoft.com/software-download/windows10)更新 Windows 版本。\n\n若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。 更新到“设置”菜单中的[最新 Windows 版本](ms-settings:windowsupdate)。\n\n 备注\n\n如果运行的是 Windows 10 版本1903 或 1909，请在 Windows 菜单中打开“设置”，导航到“更新和安全性”，然后选择“检查更新”。 内部版本号必须是 18362.1049+ 或 18363.1049+，次要内部版本号需要高于 .1049。 阅读详细信息：[WSL 2 即将支持 Windows 10 版本 1903 和 1909](https://devblogs.microsoft.com/commandline/wsl-2-support-is-coming-to-windows-10-versions-1903-and-1909/)。\n\n## 步骤 3 - 启用虚拟机功能\n\n安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要[虚拟化功能](https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting#error-0x80370102-the-virtual-machine-could-not-be-started-because-a-required-feature-is-not-installed)才能使用此功能。\n\n以管理员身份打开 PowerShell 并运行：\n\nPowerShell复制\n\n```powershell\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n```\n\n**重新启动**计算机，以完成 WSL 安装并更新到 WSL 2。\n\n## 步骤 4 - 下载 Linux 内核更新包\n\n1. 下载最新包：\n\n   - [适用于 x64 计算机的 WSL2 Linux 内核更新包](https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi)\n\n    备注\n\n   如果使用的是 ARM64 计算机，请下载 [ARM64 包](https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_arm64.msi)。 如果不确定自己计算机的类型，请打开命令提示符或 PowerShell，并输入：`systeminfo | find \"System Type\"`。 **Caveat：** 在非英文版 Windows 上，你可能必须修改搜索文本，对“System Type”字符串进行翻译。 你可能还需要对引号进行转义来用于 find 命令。 例如，在德语版中使用 `systeminfo | find '\"Systemtyp\"'`。\n\n2. 运行上一步中下载的更新包。 （双击以运行 - 系统将提示你提供提升的权限，选择“是”以批准此安装。）\n\n安装完成后，请继续执行下一步 - 在安装新的 Linux 分发时，将 WSL 2 设置为默认版本。 （如果希望将新的 Linux 安装设置为 WSL 1，请跳过此步骤。）\n\n 备注\n\n有关详细信息，请参阅 [Windows 命令行博客](https://aka.ms/cliblog)上的文章[对更新 WSL2 Linux 内核的更改](https://devblogs.microsoft.com/commandline/wsl2-will-be-generally-available-in-windows-10-version-2004)。\n\n## 步骤 5 - 将 WSL 2 设置为默认版本\n\n打开 PowerShell，然后在安装新的 Linux 发行版时运行以下命令，将 WSL 2 设置为默认版本：\n\nPowerShell复制\n\n```powershell\nwsl --set-default-version 2\n```\n\n## 步骤 6 - 安装所选的 Linux 分发\n\n1. 打开 [Microsoft Store](https://aka.ms/wslstore)，并选择你偏好的 Linux 分发版。\n","tags":["WSL"]},{"title":"Hexo-Theme-AirCloud","url":"/2022/03/09/Hexo-Theme-AirCloud/","content":"\n\n\n## Hexo-Theme-AirCloud: 一个简洁轻量的 hexo 博客主题\n\n## 功能简介\n\nHexo-Theme-AirCloud 是一个简洁轻量的 hexo 博客主题，旨在将中心放在博文本身，因此：\n\n- 默认没有大范围的主题色块、图片铺排等，也不要求每片博文配图，一方面这并不是我们记录知识的重点，另外一方面可能程序员群体并没有足够的素材，容易造成主题纠纷。\n- 建议通过不冗余的内容进行传达，比如默认没有博文摘要，因为不少开发者写博客的时候没有写博文摘要，如果从博客前一部分截取往往不能表达完整思想。\n\n另外，该主题主要实现的功能有:\n\n- 全局搜索功能，并对搜索内容进行高亮。\n- 博客评论功能，目前接入 [gitment](https://imsun.net/posts/gitment-introduction/)，之后考虑接入多种可选。\n- 文章详情页文章目录功能\n- 访问量统计（总体UV、PV，单页PV）\n- 语言切换能力，目前支持中文和英文\n\n## 起步\n\n> 我在”常见问题”中总结了该项目之前被提及的一些问题，如果你在使用过程中遇到了问题，可以在”常见问题”中寻找答案，如果没能解决，欢迎提[issue](https://github.com/aircloud/hexo-theme-aircloud/issues)，我会保证回复。\n\n注意，如果你不按照”功能适配”部分的内容进行操作，可能会导致相关提及的功能无法正常使用。\n\n- [基本使用](https://github.com/aircloud/hexo-theme-aircloud#基本使用)\n- 功能适配\n  - [搜索功能](https://github.com/aircloud/hexo-theme-aircloud#搜索功能)\n  - [`标签`页面 & `关于`页面](https://github.com/aircloud/hexo-theme-aircloud#标签页面--关于页面)\n  - [评论功能](https://github.com/aircloud/hexo-theme-aircloud#评论功能)\n  - [favicon 的配置](https://github.com/aircloud/hexo-theme-aircloud#标签页面--关于页面)\n  - [底部自定义](https://github.com/aircloud/hexo-theme-aircloud#底部自定义)\n- 高级自定义\n  - [首行缩进](https://github.com/aircloud/hexo-theme-aircloud#首行缩进)\n- 常见问题\n  - [如何取消赞赏功能？](https://github.com/aircloud/hexo-theme-aircloud#如何取消赞赏功能)\n- [一些注意事项](https://github.com/aircloud/hexo-theme-aircloud#一些注意事项)\n\n## 基本使用\n\n**建议：参考 [DEMO](https://github.com/aircloud/hexo-aircloud-blog) 进行配置，尤其是 _config.yml 部分，否则可能会造成功能缺失**\n\n同其他博客主题使用方式相同，直接 clone 或者下载本项目，复制粘贴到 themes 文件夹下即可。\n\n具体的 _config.yml 自定义配置，请参考[DEMO](https://github.com/aircloud/hexo-aircloud-blog)。\n\n## 功能适配\n\n### 搜索功能\n\n为了使用搜索功能，首先需要安装下列插件：\n\n```\nnpm i hexo-generator-search --save\n```\n\n然后在 _config.yml 中进行配置，可以参考如下配置：\n\n```\nsearch:\n  path: search.json\n  field: post\n```\n\n### `标签`页面 & `关于`页面\n\n如果是新项目，默认是没有`标签`页面和`关于`页面的，需要在`source`文件夹下建立`tags`文件夹和`about`文件夹。\n\n> 注：建议不要直接新建文件，而是采用 hexo 的 `hexo new page tags` 和 `hexo new page about` 的方式新建文件，这样可以被 hexo 索引到。\n\n其中`tags`文件夹中新建`index.md`并写入：\n\n```\n---\nlayout: \"tags\"\ntitle: \"Tags\"\n---\n```\n\n`about`文件夹下`index.md`为一篇支持 markdown 格式的文件，需要在开头添加：\n\n```\n---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ncomments: true\n---\n```\n\n### 评论功能\n\n目前，本博客支持以下评论功能：\n\n- [gitment](https://imsun.net/posts/gitment-introduction/)（gitment 经常会出现限频或者 404 等错误，其作者已关闭github认证转发服务）\n- [disqus](https://disqus.com/)\n- [LiveRe](https://www.livere.com/)\n\n#### gitment\n\n建议先在[gitment](https://imsun.net/posts/gitment-introduction/)进行了解，然后参考[DEMO](https://github.com/aircloud/hexo-aircloud-blog)进行配置，其中一些相关项目如下：\n\n```\ncomment:\n  type: gitment\n  id: your-id-created-by-https://github.com/settings/applications/new\n  secret: your-secret-created-by-https://github.com/settings/applications/new\n  owner: aircloud\n  repo: hexo-aircloud-blog\n```\n\n#### disqus\n\ndisqus 是一个使用比较广泛的评论系统，我们需要先在[官方网站](https://disqus.com/)注册一个账号。\n\n登录后，点击首页的 GET STARTED 按钮，之后选择 I want to install Disqus on my site 选项，填写相关内容，值得注意的是，`Website Name` 需要全网唯一，而且，一般情况，假设你的 `Website Name` 填写的是 example，那么下文 `script` 字段就可以写 `'https://example.disqus.com/embed.js'`。\n\n当然，你也可以在下一步 -> 选择 basic 免费套餐 -> 选择最后的 “I don’t see my platform listed, installed manually with universal code” -> 找到代码中的 `s.src = 'https://xxxx.disqus.com/embed.js'; `, 从而找到 script 地址。(无需插入 disqus 给出的脚本，只需按照这里的说明配置即可)\n\n之后，你需要在 `_config.yml` 中配置如下内容：\n\n```\ncomment:\n   type: disqus\n   script: 'https://example.disqus.com/embed.js'\n```\n\n当然，你也可以配置`url` 和 `identifier`， 但是这个就属于高级内容了，对于我们一般的 hexo 博客网站来说必要性不大，如果你需要配置这些内容，可能你已经是一个高级玩家了，可以在 `themes/aircloud/layout/layout.ejs` 的相关代码的基础上进行改动。\n\n> 注意: 目前，直接嵌入 disqus 的代码可能会加载失败，你也可以考虑将相关代码放在自己的博客下引入：在 public 文件夹下新建文件放入代码，跟随发布即可（放入 source 文件夹下可能会由于 hexo 的处理变得有错误），并同时更改 `_config.yml` 中的配置。\n\n#### LiveRe\n\nLiveRe 是一款来自韩国的支持中文且没有被墙LiveRe评论插件，重点是使用无需翻墙。\n\n该插件分为city和premium两个版本，其中city版是适合所有人使用的免费版本,有更高需求的可以考虑premium版本。\n\n注册之后，选择 安装 -> 选 city版本，按提示操作进入到管理页面，系统会给出一段嵌入代码，找到其中的data-id和data-uid。\n\n之后，你需要在`_config.yml`中配置如下内容\n\n```\ncomment:\n   type: livere\n   livere_id: 'city'\n   livere_uid: \n```\n\n`livere_id` 和 `livere_uid`就是注册后获得的 data-id和data-uid。\n\n### favicon 的配置\n\n项目的 favicon 默认在你的博客根目录的 `/source/img` 下面，在 `/source/img` 下面添加 favicon.ico 即可，不要添加在主题文件夹内。\n\n### 底部自定义\n\n大家如果访问提供的预览链接，会发现我们的博客底部是提供一些内容的：一些社交平台的个人主页链接、友情链接、PV、UV 与 本模版链接。\n\n一般情况下，大家无需改动底部的代码，直接在 `_config.yml` 中配置即可。\n\n配置社交平台主页的样例代码：\n\n```\n# SNS settings\n# 一些社交平台地址，支持以下几种：\nweibo_username:     3286578617\nzhihu_username:     ai-er-lan-xue-da\ngithub_username:    AirCloud\ntwitter_username:   iconie_alloy\nfacebook_username:  xiaotao.nie.5\nlinkedin_username:  小涛-聂-80964aba\n```\n\n如果不想包括某些社交平台，直接注释或删除相关代码即可（目前暂不支持在不改动模版代码的前提下新增社交平台）。\n\n配置友情链接的样例代码：\n\n```\n# Friends\n# 友情链接\nfriends: [\n    {\n        title: \"10000H\",\n        href: \"https://www.10000h.top\"\n    },{\n        title: \"Xiaotao's Page\",\n        href: \"https://niexiaotao.com\"\n    },{\n        title: \"It helps SEO\",\n        href: \"#\"\n    }\n]\n```\n\n最底部的 PV、UV 和模版地址，无需配置。\n\n## 高级自定义\n\n### 首行缩进\n\n目前可以配置是否在博客页面带有首行缩进两个汉字的效果，默认是有首行缩进的效果的，但是也可以通过下面的配置代码进行关闭：\n\n```\npost_style:\n    indent: 0\n```\n\n### 头像圆角\n\n```\navatar_style:\n  radius: true\n```\n\n## 常见问题\n\n### 如何取消赞赏功能？\n\n目前网站的赞赏功能做的比较鸡肋，缺乏一定的丰富度，如果你想取消这个功能，只需取消注释或者删除掉赞赏部分的相关配置即可：\n\n```\ndonate:\n  img: img/donate.jpg\n  content: 感谢鼓励\n```\n\n另外，如果你对赞赏部分有用户体验较好并且通用型比较好的设计，也可以提 issue，我会考虑实现。\n\n## 一些注意事项\n\n由于一些hexo的历史遗留问题等，为了避免给用户在使用过程中带来太多麻烦(比如需要改动主题代码甚至hexo源码)，建议用户使用过程中遵循一些规范：\n\n- 文章不要有跳级目录，比如一个`###`三级目录下是一个`#####`五级目录，然后又有一个`###`三级目录，这样有可能导致 hexo 解析出错，从而影响文章目录部分的展示。\n- 文章的段落(p)都有默认的两个字符的首行缩进，虽然能识别 markdown 段落中的换行，但是无法对换行后的内容进行缩进，所以这里需要注意样式问题(如果需要多行缩进，建议使用多个段落或者做成列表)。\n","tags":["Hexo"]}]